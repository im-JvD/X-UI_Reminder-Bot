import os
import asyncio
import aiosqlite
import time
import traceback
import json
import logging
import jdatetime
import math
from datetime import datetime
from zoneinfo import ZoneInfo
from typing import Dict, List, Tuple, Any

from aiogram import Bot, Dispatcher, F
from aiogram.filters import Command
from aiogram.types import (
    Message, CallbackQuery,
    ReplyKeyboardMarkup, KeyboardButton,
    InlineKeyboardMarkup, InlineKeyboardButton,
)
from aiogram.client.default import DefaultBotProperties
from aiogram.exceptions import TelegramForbiddenError, TelegramBadRequest
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from dotenv import load_dotenv
from pathlib import Path

logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")

def log_error(e: Exception):
    try:
        with open("log.txt", "a", encoding="utf-8") as f:
            f.write(f"[{time.ctime()}]\n{traceback.format_exc()}\n")
    except Exception:
        pass

load_dotenv(dotenv_path=Path(__file__).resolve().parent / ".env")

BOT_TOKEN = os.getenv("BOT_TOKEN", "")
REQUIRED_CHANNEL_ID = os.getenv("REQUIRED_CHANNEL_ID", "")
SUPERADMINS = {int(x) for x in os.getenv("SUPERADMINS", "").split(",") if x.strip()}

# Multi-panel support
PANEL_BASE = os.getenv("PANEL_BASE", "").rstrip("/")
WEBBASEPATH = os.getenv("WEBBASEPATH", "").rstrip("/")
PANEL_USERNAME = os.getenv("PANEL_USERNAME", "")
PANEL_PASSWORD = os.getenv("PANEL_PASSWORD", "")

if PANEL_BASE and WEBBASEPATH:
    LOGIN_URL = f"{PANEL_BASE}{WEBBASEPATH}/login"
elif PANEL_BASE:
    LOGIN_URL = f"{PANEL_BASE}/login"
else:
    LOGIN_URL = ""

EXPIRING_DAYS_THRESHOLD = int(os.getenv("EXPIRING_DAYS_THRESHOLD", "1"))
EXPIRING_GB_THRESHOLD = int(os.getenv("EXPIRING_GB_THRESHOLD", "1"))

DAILY_REPORT_HOUR = int(os.getenv("DAILY_REPORT_HOUR", "0"))
DAILY_REPORT_MINUTE = int(os.getenv("DAILY_REPORT_MINUTE", "0"))
CHANGE_CHECK_INTERVAL_MINUTES = int(os.getenv("CHANGE_CHECK_INTERVAL_MINUTES", "8"))

# üîç Validation
if not (0 <= DAILY_REPORT_HOUR <= 23):
    DAILY_REPORT_HOUR = 0
if not (0 <= DAILY_REPORT_MINUTE <= 59):
    DAILY_REPORT_MINUTE = 0
if CHANGE_CHECK_INTERVAL_MINUTES < 1:
    CHANGE_CHECK_INTERVAL_MINUTES = 8

EXPIRING_SECONDS_THRESHOLD = EXPIRING_DAYS_THRESHOLD * 24 * 3600
EXPIRING_BYTES_THRESHOLD = EXPIRING_GB_THRESHOLD * (1024**3)

# ---------------- Panel API ----------------
try:
    from api import PanelAPI
except Exception:
    class PanelAPI:
        def __init__(self, user, pwd, base_url="", web_base_path=""):
            self.user, self.pwd = user, pwd
            self.base_url = base_url
            self.web_base_path = web_base_path
        def login(self):
            return True
        def inbounds(self) -> List[dict]:
            return []
        def online_clients(self) -> List[str]:
            return []

# ---------------- Bot / Dispatcher / Scheduler ----------------
bot = Bot(BOT_TOKEN, default=DefaultBotProperties(parse_mode="HTML"))
dp = Dispatcher()
scheduler = AsyncIOScheduler()

current_action: Dict[int, Tuple[str, Any]] = {}

# ---------------- Keyboards ----------------
MANAGE_RESELLERS_KB = InlineKeyboardMarkup(inline_keyboard=[
    [InlineKeyboardButton(text="‚ûï ÿßŸÅÿ≤ŸàÿØŸÜ ÿßÿØŸÖ€åŸÜ ÿ¨ÿØ€åÿØ", callback_data="add_reseller")],
    [InlineKeyboardButton(text="üîÅ Ÿà€åÿ±ÿß€åÿ¥ ÿßÿØŸÖ€åŸÜ", callback_data="edit_reseller")],
    [InlineKeyboardButton(text="‚ùå ÿ≠ÿ∞ŸÅ ÿßÿØŸÖ€åŸÜ", callback_data="delete_reseller")],
    [InlineKeyboardButton(text="üìú ŸÑ€åÿ≥ÿ™ ŸÜŸÖÿß€åŸÜÿØ⁄ØÿßŸÜ ŸÅÿ±Ÿàÿ¥", callback_data="list_resellers")],
])

MANAGE_PANELS_KB = InlineKeyboardMarkup(inline_keyboard=[
    [InlineKeyboardButton(text="‚ûï ÿßŸÅÿ≤ŸàÿØŸÜ ŸæŸÜŸÑ ÿ¨ÿØ€åÿØ", callback_data="add_panel")],
    [InlineKeyboardButton(text="üóë ÿ≠ÿ∞ŸÅ ŸæŸÜŸÑ", callback_data="delete_panel")],
    [InlineKeyboardButton(text="üìú ŸÑ€åÿ≥ÿ™ ŸæŸÜŸÑ‚ÄåŸáÿß", callback_data="list_panels")],
])

def get_main_kb(user_id: int) -> ReplyKeyboardMarkup:
    if user_id in SUPERADMINS:
        return ReplyKeyboardMarkup(
            keyboard=[
                [KeyboardButton(text="üìä ⁄Øÿ≤ÿßÿ±ÿ¥ ⁄©ŸÑ€å")],
                [KeyboardButton(text="üü¢ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ¢ŸÜŸÑÿß€åŸÜ"), KeyboardButton(text="‚è≥ ÿ±Ÿà ÿ®Ÿá ÿßŸÜŸÇÿ∂ÿß"), KeyboardButton(text="üö´ ŸÖŸÜŸÇÿ∂€å‚Äåÿ¥ÿØŸá")],
                [KeyboardButton(text="üßë‚Äçüíº ŸÜŸÖÿß€åŸÜÿØ⁄ØÿßŸÜ ŸÅÿ±Ÿàÿ¥"), KeyboardButton(text="üéõ ŸÖÿØ€åÿ±€åÿ™ ŸæŸÜŸÑ‚ÄåŸáÿß")]
            ],
            resize_keyboard=True,
            input_field_placeholder="⁄Øÿ≤€åŸÜŸá ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ ..."
        )
    else:
        return ReplyKeyboardMarkup(
            keyboard=[
                [KeyboardButton(text="üìä ⁄Øÿ≤ÿßÿ±ÿ¥ ⁄©ŸÑ€å")],
                [KeyboardButton(text="üü¢ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ¢ŸÜŸÑÿß€åŸÜ")],
                [KeyboardButton(text="‚è≥ ÿ±Ÿà ÿ®Ÿá ÿßŸÜŸÇÿ∂ÿß"), KeyboardButton(text="üö´ ŸÖŸÜŸÇÿ∂€å‚Äåÿ¥ÿØŸá")]
            ],
            resize_keyboard=True,
            input_field_placeholder="⁄Øÿ≤€åŸÜŸá ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ ..."
        )

def safe_text(text: str) -> str:
    """Escape special characters for HTML parsing."""
    if not text:
        return ""
    return str(text).replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

# ---------------- Database ----------------
async def ensure_db():
    """
    Ensures the database and its tables are created with the new multi-panel schema.
    """
    async with aiosqlite.connect("data.db") as db:
        await db.execute("PRAGMA foreign_keys = ON")

        await db.executescript("""
        CREATE TABLE IF NOT EXISTS panels (
            panel_id INTEGER PRIMARY KEY AUTOINCREMENT,
            panel_name TEXT UNIQUE NOT NULL,
            base_url TEXT NOT NULL,
            web_base_path TEXT,
            username TEXT NOT NULL,
            password TEXT NOT NULL
        );

        CREATE TABLE IF NOT EXISTS users (
            telegram_id INTEGER PRIMARY KEY,
            role TEXT NOT NULL DEFAULT 'user'
        );

        CREATE TABLE IF NOT EXISTS reseller_inbounds (
            telegram_id INTEGER NOT NULL,
            panel_id INTEGER NOT NULL,
            inbound_id INTEGER NOT NULL,
            PRIMARY KEY (telegram_id, panel_id, inbound_id),
            FOREIGN KEY (panel_id) REFERENCES panels (panel_id) ON DELETE CASCADE
        );

        CREATE TABLE IF NOT EXISTS last_reports (
            telegram_id INTEGER PRIMARY KEY,
            last_json TEXT,
            last_full_report INTEGER
        );
        """)
        await db.commit()
        logging.info("DataBase Schema Checked and ensured.")

async def ensure_user_and_check_new(tg_id: int) -> bool:
    async with aiosqlite.connect("data.db") as db:
        cur = await db.execute("SELECT 1 FROM users WHERE telegram_id=?", (tg_id,))
        row = await cur.fetchone()
        if row:
            return False
        await db.execute("INSERT INTO users(telegram_id, role) VALUES (?, 'user')", (tg_id,))
        await db.commit()
        return True

async def get_panel_api(panel_id: int) -> PanelAPI | None:
    """
    Fetches panel credentials from DB, creates an API instance, and logs in.
    Returns the logged-in API instance or None on failure.
    """
    async with aiosqlite.connect("data.db") as db:
        cur = await db.execute("SELECT base_url, web_base_path, username, password FROM panels WHERE panel_id=?", (panel_id,))
        panel_data = await cur.fetchone()

    if not panel_data:
        logging.error(f"Could not find credentials for panel ID {panel_id} in the database.")
        return None

    base_url, web_base_path, username, password = panel_data
    api = PanelAPI(username, password, base_url, web_base_path)

    try:
        if api.login():
            return api
        else:
            return None
    except Exception as e:
        log_error(e)
        logging.error(f"An exception occurred during login to panel ID {panel_id}: {e}")
        return None

async def _get_scope_inbound_ids(tg_id: int) -> List[int]:
    """
    Returns a list of all inbound IDs assigned to a user across all panels.
    For superadmins, returns all inbound IDs from all panels.
    Skips panels that no longer exist in the database.
    """
    inbound_ids = set()

    async with aiosqlite.connect("data.db") as db:
        if tg_id in SUPERADMINS:
            # For Superadmins, get all inbounds from ALL panels
            async with db.execute("SELECT panel_id FROM panels") as panel_cur:
                all_panels = await panel_cur.fetchall()
                for (panel_id,) in all_panels:
                    api = await get_panel_api(panel_id)
                    if not api:
                        logging.warning(f"Could not get API for panel {panel_id}, skipping...")
                        continue
                    try:
                        data = api.inbounds()
                        panel_inbound_ids = [ib['id'] for ib in data if isinstance(ib, dict) and 'id' in ib]
                        inbound_ids.update(panel_inbound_ids)
                    except Exception as e:
                        log_error(e)
                        logging.error(f"Error fetching inbounds for panel {panel_id} for superadmin: {e}")
        else:
            # For Resellers, get their specific assigned inbounds
            # First, get all valid panel IDs
            async with db.execute("SELECT panel_id FROM panels") as panel_cur:
                valid_panels = {row[0] for row in await panel_cur.fetchall()}
            
            # Get reseller's inbounds, but only for panels that still exist
            async with db.execute(
                """
                SELECT ri.inbound_id, ri.panel_id 
                FROM reseller_inbounds ri
                WHERE ri.telegram_id = ?
                """, (tg_id,)
            ) as cur:
                rows = await cur.fetchall()
                for (inbound_id, panel_id) in rows:
                    # Skip if panel no longer exists
                    if panel_id not in valid_panels:
                        logging.warning(f"Panel {panel_id} assigned to reseller {tg_id} no longer exists, skipping inbound {inbound_id}")
                        # Optional: Clean up orphaned records
                        await db.execute(
                            "DELETE FROM reseller_inbounds WHERE telegram_id = ? AND panel_id = ?",
                            (tg_id, panel_id)
                        )
                        await db.commit()
                        continue
                    inbound_ids.add(inbound_id)
                
    return list(inbound_ids)

async def _get_scope_inbounds_by_panel(tg_id: int) -> Dict[int, List[int]]:
    """
    Returns a dictionary mapping panel_id to a list of its assigned inbound_ids for a user.
    For superadmins, it returns all inbounds from all panels.
    Handles deleted panels gracefully.
    """
    scoped_inbounds = {}
    
    async with aiosqlite.connect("data.db") as db:
        # Get all valid panels first
        async with db.execute("SELECT panel_id FROM panels") as panel_cur:
            valid_panels = {row[0] for row in await panel_cur.fetchall()}
        
        if not valid_panels:
            logging.warning("No panels found in database")
            return scoped_inbounds

        if tg_id in SUPERADMINS:
            # For Superadmins, get all inbounds from ALL valid panels
            for panel_id in valid_panels:
                api = await get_panel_api(panel_id)
                if not api:
                    logging.warning(f"Could not get API for panel {panel_id}, skipping...")
                    continue
                try:
                    data = api.inbounds()
                    if not data or not isinstance(data, list):
                        logging.warning(f"Panel {panel_id}: No valid inbounds data")
                        continue
                    
                    inbound_ids = [ib['id'] for ib in data if isinstance(ib, dict) and 'id' in ib]
                    if inbound_ids:
                        scoped_inbounds[panel_id] = inbound_ids
                except Exception as e:
                    log_error(e)
                    logging.error(f"Error fetching inbounds for panel {panel_id} for superadmin: {e}")
        else:
            # For Resellers, get their specific assigned inbounds
            async with db.execute(
                "SELECT panel_id, inbound_id FROM reseller_inbounds WHERE telegram_id=?", (tg_id,)
            ) as cur:
                rows = await cur.fetchall()
                for panel_id, inbound_id in rows:
                    # Skip if panel no longer exists
                    if panel_id not in valid_panels:
                        logging.warning(f"Reseller {tg_id}: Panel {panel_id} no longer exists, cleaning up...")
                        # Clean up orphaned records
                        await db.execute(
                            "DELETE FROM reseller_inbounds WHERE telegram_id = ? AND panel_id = ?",
                            (tg_id, panel_id)
                        )
                        await db.commit()
                        continue
                    
                    if panel_id not in scoped_inbounds:
                        scoped_inbounds[panel_id] = []
                    scoped_inbounds[panel_id].append(inbound_id)
                    
    return scoped_inbounds


# ---------------- Helper Functions for Client Processing ----------------
# Replace the _calc_status_for_client function with the improved version above
def _calc_status_for_client(client: dict, now: float) -> Tuple[bool, bool]:
    """
    Calculates if a client is expiring or expired.
    """
    try:
        # Extract usage data - TRY MULTIPLE FIELDS
        up = int(client.get("up", 0) or client.get("up", 0) or 0)
        down = int(client.get("down", 0) or client.get("down", 0) or 0)
        used_bytes = up + down
        
        # Try multiple total fields (like old code)
        total_gb_val = client.get("totalGB", 0) or client.get("totalGB", 0) or 0
        total_bytes_val = client.get("total", 0) or client.get("total", 0) or 0
        total_gb_raw = client.get("totalGB", 0)  # Raw value from API
        
        # Calculate total_bytes using the same logic as old code
        total_bytes = 0
        if float(total_gb_val or 0) > 0:
            # If totalGB exists, convert to bytes
            total_bytes = int(float(total_gb_val) * (1024**3))
            logging.debug(f"Using totalGB={total_gb_val}, converted to {total_bytes} bytes")
        elif float(total_bytes_val or 0) > 0:
            # Fallback to total (bytes)
            total_bytes = int(float(total_bytes_val))
            logging.debug(f"Using total={total_bytes_val} bytes directly")
        else:
            # Try alternative fields
            alt_total_gb = client.get("totalGB", 0) or client.get("limit", 0) or 0
            if float(alt_total_gb) > 0:
                total_bytes = int(float(alt_total_gb) * (1024**3))
                logging.debug(f"Using alternative totalGB={alt_total_gb}")

        # Expiry time
        expiry_ms = int(client.get("expiryTime", 0) or client.get("expire", 0) or client.get("expiry", 0) or 0)
        now_ts = now

        # Calculate remaining
        left_bytes = None
        if total_bytes > 0:
            left_bytes = total_bytes - used_bytes
            logging.debug(f"Client {client.get('email', 'unknown')}: used={used_bytes}, total={total_bytes}, left={left_bytes}")

        # Check expiration (same as old logic)
        expired_quota = (left_bytes is not None and left_bytes <= 0)
        expired_time = (expiry_ms > 0 and (expiry_ms / 1000.0) <= now_ts)
        is_expired = expired_quota or expired_time

        logging.debug(f"Client {client.get('email', 'unknown')}: expired_quota={expired_quota}, expired_time={expired_time}, is_expired={is_expired}")

        # Check if expiring (not expired)
        is_expiring = False
        if not is_expired:
            # Expiring time
            expiring_time = False
            if expiry_ms > 0:
                secs_left = (expiry_ms / 1000.0) - now_ts
                if 0 < secs_left <= EXPIRING_SECONDS_THRESHOLD:
                    expiring_time = True
                    logging.debug(f"Client expiring by time: {secs_left:.0f} seconds left")

            # Expiring quota
            expiring_quota = False
            if left_bytes is not None and total_bytes > 0:
                if 0 < left_bytes <= EXPIRING_BYTES_THRESHOLD:
                    expiring_quota = True
                    logging.debug(f"Client expiring by quota: {left_bytes} bytes left")

            if expiring_time or expiring_quota:
                is_expiring = True

        logging.debug(f"Client {client.get('email', 'unknown')}: is_expiring={is_expiring}, is_expired={is_expired}")
        return is_expiring, is_expired
        
    except (ValueError, TypeError, KeyError) as e:
        logging.warning(f"Error calculating status for client {client.get('email', 'unknown')}: {e}")
        logging.debug(f"Client data: {client}")
        return False, False

# Replace the _extract_clients_from_inbound function with the improved version above
def _extract_clients_from_inbound(inbound: dict) -> List[dict]:
    """
    Extracts client data from an inbound configuration. Tries multiple possible locations.
    """
    clients = []
    
    if not isinstance(inbound, dict):
        logging.warning("Inbound is not a dict")
        return clients
    
    inbound_id = inbound.get('id', 'unknown')
    
    # Method 1: Direct clientStats (most common in X-UI)
    if 'clientStats' in inbound and isinstance(inbound['clientStats'], list):
        clients = inbound['clientStats']
        logging.debug(f"Inbound {inbound_id}: Found {len(clients)} clients in 'clientStats'")
    
    # Method 2: Settings -> clients (JSON encoded or dict)
    elif 'settings' in inbound:
        try:
            if isinstance(inbound['settings'], str):
                settings = json.loads(inbound['settings'])
            else:
                settings = inbound['settings']
            
            if isinstance(settings, dict) and 'clients' in settings and isinstance(settings['clients'], list):
                clients = settings['clients']
                logging.debug(f"Inbound {inbound_id}: Found {len(clients)} clients in 'settings.clients'")
        except (json.JSONDecodeError, TypeError) as e:
            logging.debug(f"Inbound {inbound_id}: Error parsing settings: {e}")
    
    # Method 3: Direct 'clients' key
    elif 'clients' in inbound and isinstance(inbound['clients'], list):
        clients = inbound['clients']
        logging.debug(f"Inbound {inbound_id}: Found {len(clients)} clients in direct 'clients' key")
    
    # Method 4: Alternative locations (some X-UI versions)
    elif 'client_list' in inbound and isinstance(inbound['client_list'], list):
        clients = inbound['client_list']
        logging.debug(f"Inbound {inbound_id}: Found {len(clients)} clients in 'client_list'")
    
    # Filter out non-dict clients and add debugging
    valid_clients = [c for c in clients if isinstance(c, dict)]
    invalid_count = len(clients) - len(valid_clients)
    
    if invalid_count > 0:
        logging.debug(f"Inbound {inbound_id}: {invalid_count} invalid clients filtered out")
        
    # Log first few clients for debugging
    for i, client in enumerate(valid_clients[:3]):
        email = client.get('email', 'no-email')
        total_gb = client.get('totalGB', client.get('total', 'N/A'))
        logging.debug(f"  Client {i+1}: {email}, total={total_gb}, has 'up'={ 'up' in client}, has 'down'={ 'down' in client}")
    
    return valid_clients

# ---------------- Panel Management ----------------
@dp.message(F.text == "üéõ ŸÖÿØ€åÿ±€åÿ™ ŸæŸÜŸÑ‚ÄåŸáÿß")
async def manage_panels_menu(m: Message):
    if m.from_user.id not in SUPERADMINS:
        return await m.answer("‚õîÔ∏è ÿß€åŸÜ ÿ®ÿÆÿ¥ ŸÅŸÇÿ∑ ÿ®ÿ±ÿß€å ÿ≥ŸàŸæÿ±ÿßÿØŸÖ€åŸÜ ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ÿßÿ≥ÿ™.")
    await m.answer("üéõ <b>ŸÖÿØ€åÿ±€åÿ™ ŸæŸÜŸÑ‚ÄåŸáÿß</b>\n⁄Øÿ≤€åŸÜŸá ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:", reply_markup=MANAGE_PANELS_KB)

@dp.callback_query(F.data == "add_panel")
async def add_panel_callback(c: CallbackQuery):
    if c.from_user.id not in SUPERADMINS: return
    admin_id = c.from_user.id
    current_action[admin_id] = ("get_panel_name", {})
    await c.message.edit_text(
        "üìù ÿ®ÿ±ÿß€å ÿßŸÅÿ≤ŸàÿØŸÜÿå <b>ŸÜÿßŸÖ ŸæŸÜŸÑ ÿ¨ÿØ€åÿØ</b> ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ...\n\n"
        "ŸÖÿ´ÿßŸÑ = <b>üá©üá™ - Germany</b>",
    )
    await c.answer()

@dp.callback_query(F.data == "list_panels")
async def list_panels_callback(c: CallbackQuery):
    if c.from_user.id not in SUPERADMINS: return
    
    async with aiosqlite.connect("data.db") as db:
        cur = await db.execute("SELECT panel_id, panel_name, base_url FROM panels")
        panels = await cur.fetchall()

    if not panels:
        await c.message.edit_text("‚ÑπÔ∏è Ÿá€å⁄Ü ŸæŸÜ€åŸÑ€å ÿØÿ± ÿ≥€åÿ≥ÿ™ŸÖ ÿ´ÿ®ÿ™ ŸÜÿ¥ÿØŸá ÿßÿ≥ÿ™.", reply_markup=MANAGE_PANELS_KB)
        await c.answer()
        return

    msg = "üìú <b>ŸÑ€åÿ≥ÿ™ ŸæŸÜŸÑ‚ÄåŸáÿß€å ÿ´ÿ®ÿ™‚Äåÿ¥ÿØŸá</b>\n\n"
    for panel_id, panel_name, base_url in panels:
        msg += f"üÜî <b>ÿ¥ŸÜÿßÿ≥Ÿá ŸæŸÜŸÑ =</b> <code>{panel_id}</code>\n"
        msg += f"üè∑ <b>ŸÜÿßŸÖ ŸæŸÜŸÑ =</b> {safe_text(panel_name)}\n"
        msg += f"üåê <b>ÿ¢ÿØÿ±ÿ≥ =</b> {safe_text(base_url)}\n\n"

    await c.message.edit_text(msg, reply_markup=MANAGE_PANELS_KB)
    await c.answer()

@dp.callback_query(F.data == "delete_panel")
async def delete_panel_callback(c: CallbackQuery):
    if c.from_user.id not in SUPERADMINS: return
    
    async with aiosqlite.connect("data.db") as db:
        cur = await db.execute("SELECT panel_id, panel_name FROM panels")
        panels = await cur.fetchall()

    if not panels:
        await c.answer("‚ÑπÔ∏è Ÿá€å⁄Ü ŸæŸÜ€åŸÑ€å ÿ®ÿ±ÿß€å ÿ≠ÿ∞ŸÅ Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ.", show_alert=True)
        return

    buttons = []
    for panel_id, panel_name in panels:
        buttons.append([InlineKeyboardButton(
            text=f"üÜî {safe_text(panel_name)}",
            callback_data=f"confirm_delete_panel:{panel_id}"
        )])
    buttons.append([InlineKeyboardButton(text="‚¨ÖÔ∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_panels_menu")])

    await c.message.edit_text(
        "ŸæŸÜŸÑ€å ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿ≠ÿ∞ŸÅ ⁄©ŸÜ€åÿØ ÿå <b>ÿßÿ≤ ŸÑ€åÿ≥ÿ™ ÿ≤€åÿ± ÿßŸÜÿ™ÿÆÿßÿ® ŸÜŸÖÿß€å€åÿØ...</b>\n\n"
        "‚ö†Ô∏è <b>ÿ™Ÿàÿ¨Ÿá =</b> ÿ®ÿß ÿ≠ÿ∞ŸÅ ŸæŸÜŸÑÿå ÿ™ŸÖÿßŸÖ ŸÜŸÖÿß€åŸÜÿØ⁄ØÿßŸÜ ŸÅÿ±Ÿàÿ¥  Ÿà ÿØÿ≥ÿ™ÿ±ÿ≥€å‚ÄåŸáÿß€å ŸÖÿ±ÿ®Ÿàÿ∑ ÿ®Ÿá ÿß€åŸÜÿ®ÿßŸÜÿØ‚ÄåŸáÿß€å ÿ¢ŸÜ ŸæŸÜŸÑ ŸÜ€åÿ≤ <b>ÿ®Ÿá ÿ∑Ÿàÿ± ⁄©ÿßŸÖŸÑ ÿ≠ÿ∞ŸÅ ÿÆŸàÿßŸáŸÜÿØ ÿ¥ÿØ.</b>",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await c.answer()

@dp.callback_query(F.data.startswith("confirm_delete_panel:"))
async def confirm_delete_panel(c: CallbackQuery):
    if c.from_user.id not in SUPERADMINS: return
    try:
        panel_id_to_delete = int(c.data.split(":")[1])
    except (IndexError, ValueError):
        await c.answer("‚ùå ÿ¥ŸÜÿßÿ≥Ÿá ŸæŸÜŸÑ ŸÜÿßŸÖÿπÿ™ÿ®ÿ± ÿßÿ≥ÿ™.", show_alert=True)
        return

    async with aiosqlite.connect("data.db") as db:
        cursor = await db.execute("SELECT panel_name FROM panels WHERE panel_id = ?", (panel_id_to_delete,))
        panel = await cursor.fetchone()
        if not panel:
            await c.answer("‚ùå ŸæŸÜŸÑ ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.", show_alert=True)
            return

        await db.execute("DELETE FROM panels WHERE panel_id = ?", (panel_id_to_delete,))
        await db.commit()

    await c.message.edit_text(
        f"‚úÖ ŸæŸÜŸÑ '<b>{safe_text(panel[0])}</b>' Ÿà ÿ™ŸÖÿßŸÖ ÿØÿßÿØŸá‚ÄåŸáÿß€å ŸÖÿ±ÿ™ÿ®ÿ∑ ÿ®ÿß ÿ¢ŸÜ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ≠ÿ∞ŸÅ ÿ¥ÿØ.",
        reply_markup=MANAGE_PANELS_KB
    )
    await c.answer()

@dp.callback_query(F.data == "back_to_panels_menu")
async def back_to_panels_menu(c: CallbackQuery):
    if c.from_user.id not in SUPERADMINS: return
    await c.message.edit_text("üéõ <b>ŸÖÿØ€åÿ±€åÿ™ ŸæŸÜŸÑ‚ÄåŸáÿß</b>", reply_markup=MANAGE_PANELS_KB)
    await c.answer()

# ---------------- Panel Input Handlers ----------------
@dp.message(F.text & ~F.command(), lambda m: m.from_user.id in SUPERADMINS and current_action.get(m.from_user.id, (None, None))[0] == "get_panel_name")
async def handle_panel_name(m: Message):
    admin_id = m.from_user.id
    panel_name = m.text.strip()
    
    if len(panel_name) < 2:
        await m.answer("‚ùå ŸÜÿßŸÖ ŸæŸÜŸÑ ÿ®ÿß€åÿØ ÿ≠ÿØÿßŸÇŸÑ 2 ⁄©ÿßÿ±ÿß⁄©ÿ™ÿ± ÿ®ÿßÿ¥ÿØ.")
        return
    
    current_action[admin_id] = ("get_panel_base_url", {"panel_name": panel_name})
    await m.answer(
        f"‚úÖ ŸÜÿßŸÖ ŸæŸÜŸÑ '<b>{safe_text(panel_name)}</b>' ÿ´ÿ®ÿ™ ÿ¥ÿØ.\n\n"
        "üåê ÿ≠ÿßŸÑÿß <b>ÿ¢ÿØÿ±ÿ≥ Ÿæÿß€åŸá</b> ŸæŸÜŸÑ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ...\n\n"
        "ŸÖÿ´ÿßŸÑ = <b>https://panel.example.com</b>",
        parse_mode="HTML"
    )

@dp.message(F.text & ~F.command(), lambda m: m.from_user.id in SUPERADMINS and current_action.get(m.from_user.id, (None, None))[0] == "get_panel_base_url")
async def handle_panel_base_url(m: Message):
    admin_id = m.from_user.id
    base_url = m.text.strip().rstrip("/")
    
    if not base_url.startswith(('http://', 'https://')):
        await m.answer("‚ùå ÿ¢ÿØÿ±ÿ≥ ÿ®ÿß€åÿØ ÿ®ÿß http:// €åÿß https:// ÿ¥ÿ±Ÿàÿπ ÿ¥ŸàÿØ.")
        return
    
    data = current_action[admin_id][1]
    data["base_url"] = base_url
    current_action[admin_id] = ("get_panel_web_path", data)
    
    await m.answer(
        f"‚úÖ ÿ¢ÿØÿ±ÿ≥ Ÿæÿß€åŸá '<b>{safe_text(base_url)}</b>' ÿ´ÿ®ÿ™ ÿ¥ÿØ.\n\n"
        "üìÅ ÿ≠ÿßŸÑÿß ŸÖÿ≥€åÿ± <b>WebPath</b>  ( ÿßÿÆÿ™€åÿßÿ±€å ) ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ...\n\n"
        "ŸÖÿ´ÿßŸÑ = <b>/panel</b>\n"
        "ÿß⁄Øÿ± ŸÜÿØÿßÿ±€åÿØÿå ŸÅŸÇÿ∑ <b>[ / ]</b>  ÿ±ÿß ÿ®Ÿá ÿ™ŸÜŸáÿß€å€å ÿßÿ±ÿ≥ÿßŸÑ ŸÜŸÖÿß€å€åÿØ !",
        parse_mode="HTML"
    )

@dp.message(F.text & ~F.command(), lambda m: m.from_user.id in SUPERADMINS and current_action.get(m.from_user.id, (None, None))[0] == "get_panel_web_path")
async def handle_panel_web_path(m: Message):
    admin_id = m.from_user.id
    web_path = m.text.strip().rstrip("/")
    
    data = current_action[admin_id][1]
    data["web_base_path"] = web_path if web_path != "/" else ""
    current_action[admin_id] = ("get_panel_username", data)
    
    await m.answer(
        f"‚úÖ ŸÖÿ≥€åÿ± <b>WebPath</b> ÿ´ÿ®ÿ™ ÿ¥ÿØ.\n\n"
        f"üë§ ÿ≠ÿßŸÑÿß <b>ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å ŸæŸÜŸÑ</b> ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ...",
        parse_mode="HTML"
    )

@dp.message(F.text & ~F.command(), lambda m: m.from_user.id in SUPERADMINS and current_action.get(m.from_user.id, (None, None))[0] == "get_panel_username")
async def handle_panel_username(m: Message):
    admin_id = m.from_user.id
    username = m.text.strip()
    
    if len(username) < 3:
        await m.answer("‚ùå ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å ÿ®ÿß€åÿØ ÿ≠ÿØÿßŸÇŸÑ 3 ⁄©ÿßÿ±ÿß⁄©ÿ™ÿ± ÿ®ÿßÿ¥ÿØ.")
        return
    
    data = current_action[admin_id][1]
    data["username"] = username
    current_action[admin_id] = ("get_panel_password", data)
    
    await m.answer(
        f"‚úÖ ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å '<b>{safe_text(username)}</b>' ÿ´ÿ®ÿ™ ÿ¥ÿØ.\n\n"
        "üîê ÿ≠ÿßŸÑÿß <b>ÿ±ŸÖÿ≤ ÿπÿ®Ÿàÿ± ŸæŸÜŸÑ</b> ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ...",
        parse_mode="HTML"
    )

@dp.message(F.text & ~F.command(), lambda m: m.from_user.id in SUPERADMINS and current_action.get(m.from_user.id, (None, None))[0] == "get_panel_password")
async def handle_panel_password(m: Message):
    admin_id = m.from_user.id
    password = m.text.strip()
    
    if len(password) < 4:
        await m.answer("‚ùå ÿ±ŸÖÿ≤ ÿπÿ®Ÿàÿ± ÿ®ÿß€åÿØ ÿ≠ÿØÿßŸÇŸÑ 4 ⁄©ÿßÿ±ÿß⁄©ÿ™ÿ± ÿ®ÿßÿ¥ÿØ.")
        return
    
    data = current_action[admin_id][1]
    data["password"] = password
    
    # Try to add the panel
    try:
        async with aiosqlite.connect("data.db") as db:
            await db.execute(
                """INSERT INTO panels (panel_name, base_url, web_base_path, username, password) 
                VALUES (?, ?, ?, ?, ?)""",
                (data["panel_name"], data["base_url"], data["web_base_path"], 
                 data["username"], data["password"])
            )
            await db.commit()
        
        # Test connection
        api = PanelAPI(data["username"], data["password"], data["base_url"], data["web_base_path"])
        if api.login():
            await m.answer(
                f"‚úÖ <b>ŸæŸÜŸÑ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ!</b>\n\n"
                f"üè∑ <b>ŸÜÿßŸÖ =</b> {safe_text(data['panel_name'])}\n"
                f"üåê <b>ÿ¢ÿØÿ±ÿ≥ =</b> {safe_text(data['base_url'])}\n"
                f"üë§ <b>ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å =</b> {safe_text(data['username'])}\n"
                f"‚úÖ <b>Ÿàÿ∂ÿπ€åÿ™ ÿ™ÿ≥ÿ™ ÿßÿ™ÿµÿßŸÑ ÿ®Ÿá ŸæŸÜŸÑ =</b> ŸÖŸàŸÅŸÇ",
                reply_markup=MANAGE_PANELS_KB,
                parse_mode="HTML"
            )
        else:
            await m.answer(
                f"‚ö†Ô∏è <b>ŸæŸÜŸÑ ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ ÿßŸÖÿß ÿßÿ™ÿµÿßŸÑ ŸÜÿßŸÖŸàŸÅŸÇ ÿßÿ≥ÿ™!</b>\n\n"
                f"ŸÑÿ∑ŸÅÿßŸã ÿßÿ∑ŸÑÿßÿπÿßÿ™ Ÿàÿ±ŸàÿØ ÿ±ÿß ÿ®ÿ±ÿ±ÿ≥€å ⁄©ŸÜ€åÿØ.\n"
                f"üè∑ <b>ŸÜÿßŸÖ =</b> {safe_text(data['panel_name'])}\n"
                f"üåê <b>ÿ¢ÿØÿ±ÿ≥ =</b> {safe_text(data['base_url'])}",
                reply_markup=MANAGE_PANELS_KB,
                parse_mode="HTML"
            )
            
    except Exception as e:
        log_error(e)
        await m.answer(
            f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿßÿ∂ÿßŸÅŸá ⁄©ÿ±ÿØŸÜ ŸæŸÜŸÑ:\n<code>{str(e)}</code>",
            reply_markup=MANAGE_PANELS_KB,
            parse_mode="HTML"
        )
    
    del current_action[admin_id]

# ---------------- Reseller Management ----------------
@dp.message(F.text == "üßë‚Äçüíº ŸÜŸÖÿß€åŸÜÿØ⁄ØÿßŸÜ ŸÅÿ±Ÿàÿ¥")
async def manage_resellers_menu(m: Message):
    if m.from_user.id not in SUPERADMINS:
        return await m.answer("‚õîÔ∏è ÿß€åŸÜ ÿ®ÿÆÿ¥ ŸÅŸÇÿ∑ ÿ®ÿ±ÿß€å ÿ≥ŸàŸæÿ±ÿßÿØŸÖ€åŸÜ ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ÿßÿ≥ÿ™.")
    await m.answer("üßë‚Äçüíº <b>ŸÖÿØ€åÿ±€åÿ™ ŸÜŸÖÿß€åŸÜÿØ⁄ØÿßŸÜ ŸÅÿ±Ÿàÿ¥</b>\n⁄Øÿ≤€åŸÜŸá ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:", reply_markup=MANAGE_RESELLERS_KB)

@dp.callback_query(F.data == "add_reseller")
async def add_reseller_callback(c: CallbackQuery):
    if c.from_user.id not in SUPERADMINS: return
    
    async with aiosqlite.connect("data.db") as db:
        cur = await db.execute("SELECT panel_id, panel_name FROM panels")
        panels = await cur.fetchall()

    if not panels:
        await c.answer("‚ùå ÿßÿ®ÿ™ÿØÿß ÿ®ÿß€åÿØ ÿ≠ÿØÿßŸÇŸÑ €å⁄© ŸæŸÜŸÑ ÿßÿ∂ÿßŸÅŸá ⁄©ŸÜ€åÿØ.", show_alert=True)
        return

    buttons = []
    for panel_id, panel_name in panels:
        buttons.append([InlineKeyboardButton(
            text=f"üè¢ {safe_text(panel_name)}",
            callback_data=f"select_panel_for_reseller:add:{panel_id}"
        )])
    buttons.append([InlineKeyboardButton(text="‚¨ÖÔ∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_main_menu_superadmin")])

    await c.message.edit_text(
        "ŸæŸÜŸÑ ŸÖŸÜÿ™ÿÆÿ® ÿß€åŸÜ ŸÜŸÖÿß€åŸÜÿØŸá ÿ±Ÿà ÿßÿ≤ ŸÑ€åÿ≥ÿ™ ÿ≤€åÿ± ÿßŸÜÿ™ÿÆÿßÿ® ŸÜŸÖÿß€å€åÿØ.",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await c.answer()

@dp.callback_query(F.data.startswith("select_panel_for_reseller:"))
async def select_panel_for_reseller_callback(c: CallbackQuery):
    if c.from_user.id not in SUPERADMINS: return

    try:
        _, action_type, panel_id_str = c.data.split(":")
        panel_id = int(panel_id_str)
    except (ValueError, IndexError):
        await c.answer("‚ùå ÿØÿßÿØŸá ŸÜÿßŸÖÿπÿ™ÿ®ÿ±.", show_alert=True)
        return

    admin_id = c.from_user.id
    data_to_store = {'panel_id': panel_id}

    if action_type == "add":
        current_action[admin_id] = ("get_reseller_id_for_add", data_to_store)
        prompt_message = "üÜî ÿ≠ÿßŸÑÿß <b>ÿ¥ŸÜÿßÿ≥Ÿá ÿ™ŸÑ⁄Øÿ±ÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å</b> ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿ®Ÿá ÿß€åŸÜ ŸæŸÜŸÑ ÿ®Ÿá ÿπŸÜŸàÿßŸÜ <b>( ŸÜŸÖÿß€åŸÜÿØŸá ŸÅÿ±Ÿàÿ¥ )</b> ÿßÿ∂ÿßŸÅŸá ÿ¥ŸàÿØ ÿ±ÿß ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ..."
    elif action_type == "edit":
        current_action[admin_id] = ("get_reseller_id_for_edit", data_to_store)
        prompt_message = "üÜî ÿ≠ÿßŸÑÿß <b>ÿ¥ŸÜÿßÿ≥Ÿá ÿ™ŸÑ⁄Øÿ±ÿßŸÖ ŸÜŸÖÿß€åŸÜÿØŸá ŸÅÿ±Ÿàÿ¥€å</b> ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ <b>ÿß€åŸÜÿ®ÿßŸÜÿØŸáÿß€å ÿßŸà ÿ±ÿß ÿØÿ± ÿß€åŸÜ ŸæŸÜŸÑ</b> Ÿà€åÿ±ÿß€åÿ¥ ⁄©ŸÜ€åÿØÿå ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ..."
    elif action_type == "delete":
        current_action[admin_id] = ("get_reseller_id_for_delete", data_to_store)
        prompt_message = "üÜî <b>ÿ¥ŸÜÿßÿ≥Ÿá ÿ™ŸÑ⁄Øÿ±ÿßŸÖ ŸÜŸÖÿß€åŸÜÿØŸá ŸÅÿ±Ÿàÿ¥€å</b> ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ <b>ÿßÿ≤ ÿß€åŸÜ ŸæŸÜŸÑ ÿ≠ÿ∞ŸÅ ÿ¥ŸàÿØ</b> ÿ±ÿß ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ..."
    else:
        return

    await c.message.edit_text(prompt_message)
    await c.answer()

@dp.message(F.text & ~F.command(), lambda m: m.from_user.id in SUPERADMINS and current_action.get(m.from_user.id, (None, None))[0] == "get_reseller_id_for_add")
async def handle_reseller_id_for_add(m: Message):
    admin_id = m.from_user.id
    try:
        reseller_id = int(m.text.strip())
    except ValueError:
        await m.answer("‚ùå ŸÑÿ∑ŸÅÿßŸã €å⁄© ÿ¥ŸÖÿßÿ±Ÿá ŸÖÿπÿ™ÿ®ÿ± Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.")
        return

    data = current_action[admin_id][1]
    data['reseller_id'] = reseller_id
    current_action[admin_id] = ("assign_inbound_for_add", data)
    
    await m.answer(
        f"‚úÖ ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿß ÿ¥ŸÜÿßÿ≥Ÿá [ <code>{reseller_id}</code> ] ÿ®ÿ±ÿß€å ÿßŸÅÿ≤ŸàÿØŸÜ ÿ®Ÿá ÿπŸÜŸàÿßŸÜ ŸÜŸÖÿß€åŸÜÿØŸá ŸÅÿ±Ÿàÿ¥ ÿßŸÜÿ™ÿÆÿßÿ® ÿ¥ÿØ.\n"
        f"ÿØÿ± ÿß€åŸÜ ŸÖÿ±ÿ≠ŸÑŸá <b>ÿ¥ŸÜÿßÿ≥Ÿá ÿß€åŸÜÿ®ÿßŸÜÿØŸáÿß€å€å</b> ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿ®Ÿá <b>ÿß€åŸÜ ⁄©ÿßÿ±ÿ®ÿ± ÿßÿÆÿ™ÿµÿßÿµ ÿØŸá€åÿØ</b>ÿå ÿ±ÿß ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ...\n"
        f"ŸÖ€å‚Äåÿ™ŸàÿßŸÜ€åÿØ ÿ¥ŸÜÿßÿ≥Ÿá ÿß€åŸÜÿ®ÿßŸÜÿØ Ÿáÿß ÿ±ÿß ÿ®ÿß [ , ] ÿßÿ≤ ŸáŸÖ ÿ¨ÿØÿß ⁄©ŸÜ€åÿØ !\n"
        f"ŸÖÿ´ÿßŸÑ = <b>1, 2, 3, ...</b>",
        parse_mode="HTML"
    )

@dp.message(F.text & ~F.command(), lambda m: m.from_user.id in SUPERADMINS and current_action.get(m.from_user.id, (None, None))[0] == "assign_inbound_for_add")
async def handle_inbound_for_add(m: Message):
    admin_id = m.from_user.id
    inbound_text = m.text.strip()
    
    try:
        # Split and clean inbound IDs
        inbound_ids = [int(x.strip()) for x in inbound_text.split(",") if x.strip().isdigit()]
        if not inbound_ids:
            await m.answer("‚ùå Ÿá€å⁄Ü ÿ¥ŸÜÿßÿ≥Ÿá ÿß€åŸÜÿ®ÿßŸÜÿØ ŸÖÿπÿ™ÿ®ÿ±€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.")
            return
        
        data = current_action[admin_id][1]
        panel_id = data['panel_id']
        reseller_id = data['reseller_id']
        
        # Verify panel exists and get inbounds
        api = await get_panel_api(panel_id)
        if not api:
            await m.answer("‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿßÿ™ÿµÿßŸÑ ÿ®Ÿá ŸæŸÜŸÑ.")
            return
        
        all_inbounds = api.inbounds()
        available_inbound_ids = [ib['id'] for ib in all_inbounds if isinstance(ib, dict) and 'id' in ib]
        
        # Filter valid inbounds
        valid_inbounds = [iid for iid in inbound_ids if iid in available_inbound_ids]
        invalid_inbounds = [iid for iid in inbound_ids if iid not in available_inbound_ids]
        
        if not valid_inbounds:
            await m.answer(
                f"‚ùå Ÿá€å⁄Ü‚Äå⁄©ÿØÿßŸÖ ÿßÿ≤ ÿ¥ŸÜÿßÿ≥Ÿá‚ÄåŸáÿß€å Ÿàÿßÿ±ÿØÿ¥ÿØŸá ŸÖÿπÿ™ÿ®ÿ± ŸÜ€åÿ≥ÿ™.\n"
                f"ÿß€åŸÜÿ®ÿßŸÜÿØŸáÿß€å ŸÖŸàÿ¨ŸàÿØ ÿØÿ± ŸæŸÜŸÑ: {', '.join(map(str, available_inbound_ids))}"
            )
            return
        
        # Add to database
        async with aiosqlite.connect("data.db") as db:
            for inbound_id in valid_inbounds:
                try:
                    await db.execute(
                        "INSERT INTO reseller_inbounds (telegram_id, panel_id, inbound_id) VALUES (?, ?, ?)",
                        (reseller_id, panel_id, inbound_id)
                    )
                except aiosqlite.IntegrityError:
                    # Already exists, skip
                    pass
            await db.commit()
        
        success_msg = f"‚úÖ <b>{len(valid_inbounds)} ÿß€åŸÜÿ®ÿßŸÜÿØ</b> ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ®Ÿá ⁄©ÿßÿ±ÿ®ÿ± <code>{reseller_id}</code> ÿßÿÆÿ™ÿµÿßÿµ €åÿßŸÅÿ™."
        if invalid_inbounds:
            success_msg += f"\n\n‚ö†Ô∏è <b>{len(invalid_inbounds)} ÿ¥ŸÜÿßÿ≥Ÿá ŸÜÿßŸÖÿπÿ™ÿ®ÿ±</b> ŸÜÿßÿØ€åÿØŸá ⁄Øÿ±ŸÅÿ™Ÿá ÿ¥ÿØ."
        
        await m.answer(
            success_msg + "\n\n⁄©ÿßÿ±ÿ®ÿ± ÿ≠ÿßŸÑÿß ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ⁄Øÿ≤ÿßÿ±ÿ¥ÿßÿ™ ŸÖÿ±ÿ®Ÿàÿ∑ ÿ®Ÿá ÿß€åŸÜ ÿß€åŸÜÿ®ÿßŸÜÿØ‚ÄåŸáÿß ÿ±ÿß ÿØÿ±€åÿßŸÅÿ™ ⁄©ŸÜÿØ.",
            reply_markup=MANAGE_RESELLERS_KB,
            parse_mode="HTML"
        )
        
    except Exception as e:
        log_error(e)
        await m.answer(f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿßÿÆÿ™ÿµÿßÿµ ÿß€åŸÜÿ®ÿßŸÜÿØ: {str(e)}")
    
    del current_action[admin_id]

@dp.callback_query(F.data == "list_resellers")
async def list_resellers_callback(c: CallbackQuery):
    if c.from_user.id not in SUPERADMINS: return
    
    async with aiosqlite.connect("data.db") as db:
        cur = await db.execute("""
            SELECT r.telegram_id, p.panel_name, GROUP_CONCAT(r.inbound_id) as inbounds
            FROM reseller_inbounds r
            JOIN panels p ON r.panel_id = p.panel_id
            GROUP BY r.telegram_id, p.panel_id
            ORDER BY r.telegram_id
        """)
        resellers = await cur.fetchall()

    if not resellers:
        await c.message.edit_text("‚ÑπÔ∏è Ÿá€å⁄Ü ŸÜŸÖÿß€åŸÜÿØŸá ÿß€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.", reply_markup=MANAGE_RESELLERS_KB)
        await c.answer()
        return

    msg = "üìú <b>ŸÑ€åÿ≥ÿ™ ŸÜŸÖÿß€åŸÜÿØ⁄ØÿßŸÜ ŸÅÿ±Ÿàÿ¥ ÿ¥ŸÖÿß</b>\n\n"
    current_user = None
    for reseller_id, panel_name, inbounds in resellers:
        if current_user != reseller_id:
            if current_user is not None:
                msg += "\n\n"
            msg += f"   üë§ <b>⁄©ÿßÿ±ÿ®ÿ± [ <code>{reseller_id}</code> ]</b>\n"
            current_user = reseller_id
        
        msg += f"  üì¶ <b>{safe_text(panel_name)} =</b> [ <code>{inbounds or 'Ÿá€å⁄Ü'}</code> ]\n"

    await c.message.edit_text(msg, reply_markup=MANAGE_RESELLERS_KB, parse_mode="HTML")
    await c.answer()

@dp.callback_query(F.data == "delete_reseller")
async def delete_reseller_callback(c: CallbackQuery):
    if c.from_user.id not in SUPERADMINS: return

    async with aiosqlite.connect("data.db") as db:
        cur = await db.execute("""
            SELECT DISTINCT p.panel_id, p.panel_name
            FROM panels p
            JOIN reseller_inbounds ri ON p.panel_id = ri.panel_id
        """)
        panels_with_resellers = await cur.fetchall()

    if not panels_with_resellers:
        await c.answer("‚ùå Ÿá€å⁄Ü ŸÜŸÖÿß€åŸÜÿØŸá ŸÅÿ±Ÿàÿ¥€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ", show_alert=True)
        return

    buttons = []
    for panel_id, panel_name in panels_with_resellers:
        buttons.append([InlineKeyboardButton(
            text=f"üè¢ {safe_text(panel_name)}",
            callback_data=f"select_panel_for_reseller:delete:{panel_id}"
        )])
    buttons.append([InlineKeyboardButton(text="‚¨ÖÔ∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_main_menu_superadmin")])

    await c.message.edit_text(
        "ŸÜŸÖÿß€åŸÜÿØŸá ÿ±ÿß ÿßÿ≤ ⁄©ÿØÿßŸÖ ŸæŸÜŸÑ ÿ≠ÿ∞ŸÅ ŸÖ€å⁄©ŸÜ€åÿØ ÿü",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await c.answer()

# ============ Edit Reseller Implementation ============

@dp.callback_query(F.data == "edit_reseller")
async def edit_reseller_callback(c: CallbackQuery):
    """ŸÜŸÖÿß€åÿ¥ ŸÑ€åÿ≥ÿ™ ŸæŸÜŸÑ‚ÄåŸáÿß ÿ®ÿ±ÿß€å ÿßŸÜÿ™ÿÆÿßÿ® ÿ¨Ÿáÿ™ Ÿà€åÿ±ÿß€åÿ¥ ŸÜŸÖÿß€åŸÜÿØŸá"""
    if c.from_user.id not in SUPERADMINS: 
        return

    async with aiosqlite.connect("data.db") as db:
        cur = await db.execute("""
            SELECT DISTINCT p.panel_id, p.panel_name
            FROM panels p
            JOIN reseller_inbounds ri ON p.panel_id = ri.panel_id
        """)
        panels_with_resellers = await cur.fetchall()

    if not panels_with_resellers:
        await c.answer("‚ùå Ÿá€å⁄Ü ŸÜŸÖÿß€åŸÜÿØŸá ŸÅÿ±Ÿàÿ¥€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ", show_alert=True)
        return

    buttons = []
    for panel_id, panel_name in panels_with_resellers:
        buttons.append([InlineKeyboardButton(
            text=f"üè¢ {safe_text(panel_name)}",
            callback_data=f"select_panel_for_reseller:edit:{panel_id}"
        )])
    buttons.append([InlineKeyboardButton(text="‚¨ÖÔ∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="back_to_main_menu_superadmin")])

    await c.message.edit_text(
        "üìù ŸæŸÜŸÑ ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿ®ÿ±ÿß€å Ÿà€åÿ±ÿß€åÿ¥ ŸÜŸÖÿß€åŸÜÿØŸá ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await c.answer()


@dp.message(F.text & ~F.command(), 
            lambda m: m.from_user.id in SUPERADMINS and 
            current_action.get(m.from_user.id, (None, None))[0] == "get_reseller_id_for_edit")
async def handle_reseller_id_for_edit(m: Message):
    """ÿØÿ±€åÿßŸÅÿ™ ÿ¥ŸÜÿßÿ≥Ÿá ŸÜŸÖÿß€åŸÜÿØŸá ÿ®ÿ±ÿß€å Ÿà€åÿ±ÿß€åÿ¥ Ÿà ŸÜŸÖÿß€åÿ¥ ŸÑ€åÿ≥ÿ™ ŸÜŸÖÿß€åŸÜÿØ⁄ØÿßŸÜ"""
    admin_id = m.from_user.id
    data = current_action[admin_id][1]
    panel_id = data['panel_id']
    
    try:
        reseller_id = int(m.text.strip())
    except ValueError:
        await m.answer("‚ùå ŸÑÿ∑ŸÅÿßŸã €å⁄© ÿ¥ŸÖÿßÿ±Ÿá ŸÖÿπÿ™ÿ®ÿ± Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.")
        return

    # ÿ®ÿ±ÿ±ÿ≥€å Ÿàÿ¨ŸàÿØ ŸÜŸÖÿß€åŸÜÿØŸá ÿØÿ± ÿß€åŸÜ ŸæŸÜŸÑ
    async with aiosqlite.connect("data.db") as db:
        cur = await db.execute(
            "SELECT inbound_id FROM reseller_inbounds WHERE telegram_id=? AND panel_id=?",
            (reseller_id, panel_id)
        )
        inbounds = await cur.fetchall()

    if not inbounds:
        await m.answer(
            f"‚ùå ⁄©ÿßÿ±ÿ®ÿ± <code>{reseller_id}</code> ÿØÿ± ÿß€åŸÜ ŸæŸÜŸÑ ŸÜŸÖÿß€åŸÜÿØŸá ŸÅÿ±Ÿàÿ¥ ŸÜ€åÿ≥ÿ™.",
            reply_markup=MANAGE_RESELLERS_KB,
            parse_mode="HTML"
        )
        del current_action[admin_id]
        return

    # ŸÜŸÖÿß€åÿ¥ ÿß€åŸÜÿ®ÿßŸÜÿØŸáÿß€å ŸÅÿπŸÑ€å
    current_inbounds = [str(row[0]) for row in inbounds]
    inbound_list = ", ".join(current_inbounds)

    # ÿ∞ÿÆ€åÿ±Ÿá ÿßÿ∑ŸÑÿßÿπÿßÿ™ ÿ®ÿ±ÿß€å ŸÖÿ±ÿ≠ŸÑŸá ÿ®ÿπÿØ
    data['reseller_id'] = reseller_id
    data['current_inbounds'] = current_inbounds
    current_action[admin_id] = ("get_new_inbounds_for_edit", data)

    await m.answer(
        f"üìã <b>ÿß€åŸÜÿ®ÿßŸÜÿØŸáÿß€å ŸÅÿπŸÑ€å ⁄©ÿßÿ±ÿ®ÿ±</b> [ <code>{reseller_id}</code> ]\n\n"
        f"<code>{inbound_list}</code>\n\n"
        f"üîÑ <b>ÿß€åŸÜÿ®ÿßŸÜÿØŸáÿß€å ÿ¨ÿØ€åÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ...</b>\n"
        f"   ‚Ä¢ ÿ®ÿ±ÿß€å ⁄ÜŸÜÿØ ÿß€åŸÜÿ®ÿßŸÜÿØ ÿßÿ≤ ⁄©ÿßŸÖÿß ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ\n"
        f"   ‚Ä¢ ŸÖÿ´ÿßŸÑ = <b>1, 2, 3, ...</b>\n\n"
        f"üí° ÿß€åŸÜÿ®ÿßŸÜÿØŸáÿß€å ÿ¨ÿØ€åÿØ ÿ¨ÿß€å⁄Øÿ≤€åŸÜ ÿß€åŸÜÿ®ÿßŸÜÿØŸáÿß€å ŸÇÿ®ŸÑ€å ŸÖ€å‚Äåÿ¥ŸàŸÜÿØ.",
        parse_mode="HTML"
    )


@dp.message(F.text & ~F.command(), 
            lambda m: m.from_user.id in SUPERADMINS and 
            current_action.get(m.from_user.id, (None, None))[0] == "get_new_inbounds_for_edit")
async def handle_new_inbounds_for_edit(m: Message):
    """ÿØÿ±€åÿßŸÅÿ™ ÿß€åŸÜÿ®ÿßŸÜÿØŸáÿß€å ÿ¨ÿØ€åÿØ Ÿà Ÿà€åÿ±ÿß€åÿ¥ ŸÜŸÖÿß€åŸÜÿØŸá"""
    admin_id = m.from_user.id
    data = current_action[admin_id][1]
    panel_id = data['panel_id']
    reseller_id = data['reseller_id']

    try:
        # Ÿæÿßÿ±ÿ≥ ⁄©ÿ±ÿØŸÜ ÿß€åŸÜÿ®ÿßŸÜÿØŸáÿß€å ÿ¨ÿØ€åÿØ
        inbound_ids_str = [x.strip() for x in m.text.strip().split(",")]
        inbound_ids = [int(x) for x in inbound_ids_str if x]
    except ValueError:
        await m.answer("‚ùå ŸÅÿ±ŸÖÿ™ ŸÜÿßÿØÿ±ÿ≥ÿ™! ŸÑÿ∑ŸÅÿßŸã ŸÅŸÇÿ∑ ÿßÿπÿØÿßÿØ Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ (ŸÖÿ´ÿßŸÑ: 1,2,3)")
        return

    if not inbound_ids:
        await m.answer("‚ùå ÿ≠ÿØÿßŸÇŸÑ €å⁄© ÿ¥ŸÜÿßÿ≥Ÿá ÿß€åŸÜÿ®ÿßŸÜÿØ ÿ®ÿß€åÿØ Ÿàÿßÿ±ÿØ ÿ¥ŸàÿØ.")
        return

    # ÿßÿπÿ™ÿ®ÿßÿ±ÿ≥ŸÜÿ¨€å ÿß€åŸÜÿ®ÿßŸÜÿØŸáÿß ÿ®ÿß API
    try:
        async with aiosqlite.connect("data.db") as db:
            cur = await db.execute(
                "SELECT base_url, web_base_path, username, password FROM panels WHERE panel_id = ?",
                (panel_id,)
            )
            panel_info = await cur.fetchone()

        if not panel_info:
            await m.answer("‚ùå ŸæŸÜŸÑ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ!")
            del current_action[admin_id]
            return

        base_url, web_base_path, username, password = panel_info
        api = PanelAPI(username, password, base_url, web_base_path or "")
        
        if not api.login():
            await m.answer("‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿßÿ™ÿµÿßŸÑ ÿ®Ÿá ŸæŸÜŸÑ!")
            del current_action[admin_id]
            return

        # ÿØÿ±€åÿßŸÅÿ™ ŸÑ€åÿ≥ÿ™ ÿß€åŸÜÿ®ÿßŸÜÿØŸáÿß€å ŸÖŸàÿ¨ŸàÿØ
        inbounds = api.inbounds()
        valid_inbound_ids = {ib.get('id') for ib in inbounds if isinstance(ib, dict) and 'id' in ib}

        # ÿ¨ÿØÿßÿ≥ÿßÿ≤€å ŸÖÿπÿ™ÿ®ÿ± Ÿà ŸÜÿßŸÖÿπÿ™ÿ®ÿ±
        valid_inbounds = [iid for iid in inbound_ids if iid in valid_inbound_ids]
        invalid_inbounds = [iid for iid in inbound_ids if iid not in valid_inbound_ids]

        if not valid_inbounds:
            await m.answer(
                "‚ùå Ÿá€å⁄Ü €å⁄© ÿßÿ≤ ÿ¥ŸÜÿßÿ≥Ÿá‚ÄåŸáÿß€å Ÿàÿßÿ±ÿØ ÿ¥ÿØŸá ŸÖÿπÿ™ÿ®ÿ± ŸÜ€åÿ≥ÿ™ŸÜÿØ!\n\n"
                f"ÿ¥ŸÜÿßÿ≥Ÿá‚ÄåŸáÿß€å ŸÜÿßŸÖÿπÿ™ÿ®ÿ±: <code>{', '.join(map(str, invalid_inbounds))}</code>",
                parse_mode="HTML"
            )
            return

        # ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿØÿ± ÿØ€åÿ™ÿßÿ®€åÿ≥
        async with aiosqlite.connect("data.db") as db:
            # ÿ≠ÿ∞ŸÅ ÿß€åŸÜÿ®ÿßŸÜÿØŸáÿß€å ŸÇÿ®ŸÑ€å
            await db.execute(
                "DELETE FROM reseller_inbounds WHERE telegram_id=? AND panel_id=?",
                (reseller_id, panel_id)
            )
            
            # ÿßÿ∂ÿßŸÅŸá ⁄©ÿ±ÿØŸÜ ÿß€åŸÜÿ®ÿßŸÜÿØŸáÿß€å ÿ¨ÿØ€åÿØ
            for inbound_id in valid_inbounds:
                await db.execute(
                    "INSERT OR IGNORE INTO reseller_inbounds (telegram_id, panel_id, inbound_id) VALUES (?, ?, ?)",
                    (reseller_id, panel_id, inbound_id)
                )
            await db.commit()

        # Ÿæ€åÿßŸÖ ŸÖŸàŸÅŸÇ€åÿ™
        success_msg = (
            f"‚úÖ ÿß€åŸÜÿ®ÿßŸÜÿØŸáÿß€å ⁄©ÿßÿ±ÿ®ÿ± [ <code>{reseller_id}</code> ] ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ¥ÿØ!\n\n"
            f"üìã <b>ÿß€åŸÜÿ®ÿßŸÜÿØŸáÿß€å ÿ¨ÿØ€åÿØ =</b> <code>{', '.join(map(str, valid_inbounds))}</code>"
        )
        
        if invalid_inbounds:
            success_msg += f"\n\n‚ö†Ô∏è <b>ÿ¥ŸÜÿßÿ≥Ÿá‚ÄåŸáÿß€å ŸÜÿßŸÖÿπÿ™ÿ®ÿ± (ŸÜÿßÿØ€åÿØŸá ⁄Øÿ±ŸÅÿ™Ÿá ÿ¥ÿØ):</b>\n<code>{', '.join(map(str, invalid_inbounds))}</code>"

        await m.answer(
            success_msg,
            reply_markup=MANAGE_RESELLERS_KB,
            parse_mode="HTML"
        )

    except Exception as e:
        log_error(e)
        await m.answer(f"‚ùå ÿÆÿ∑ÿß ÿØÿ± Ÿà€åÿ±ÿß€åÿ¥ ÿß€åŸÜÿ®ÿßŸÜÿØŸáÿß: {str(e)}")

    del current_action[admin_id]

@dp.message(F.text & ~F.command(), lambda m: m.from_user.id in SUPERADMINS and current_action.get(m.from_user.id, (None, None))[0] == "get_reseller_id_for_delete")
async def handle_reseller_id_for_delete(m: Message):
    admin_id = m.from_user.id
    try:
        reseller_id = int(m.text.strip())
    except ValueError:
        await m.answer("‚ùå ŸÑÿ∑ŸÅÿßŸã €å⁄© ÿ¥ŸÖÿßÿ±Ÿá ŸÖÿπÿ™ÿ®ÿ± Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.")
        return

    data = current_action[admin_id][1]
    panel_id = data['panel_id']
    
    # Check if reseller exists in this panel
    async with aiosqlite.connect("data.db") as db:
        cur = await db.execute(
            "SELECT COUNT(*) FROM reseller_inbounds WHERE telegram_id=? AND panel_id=?",
            (reseller_id, panel_id)
        )
        count = await cur.fetchone()
        
        if count[0] == 0:
            await m.answer(
                f"‚ùå ⁄©ÿßÿ±ÿ®ÿ± <code>{reseller_id}</code> ÿØÿ± ÿß€åŸÜ ŸæŸÜŸÑ ŸÜŸÖÿß€åŸÜÿØŸá ŸÅÿ±Ÿàÿ¥ ŸÜ€åÿ≥ÿ™.",
                reply_markup=MANAGE_RESELLERS_KB,
                parse_mode="HTML"
            )
            del current_action[admin_id]
            return
        
        # Delete the reseller from this panel
        await db.execute(
            "DELETE FROM reseller_inbounds WHERE telegram_id=? AND panel_id=?",
            (reseller_id, panel_id)
        )
        await db.commit()
    
    await m.answer(
        f"‚úÖ ÿ™ŸÖÿßŸÖ ÿØÿ≥ÿ™ÿ±ÿ≥€å‚ÄåŸáÿß€å ⁄©ÿßÿ±ÿ®ÿ± [ <code>{reseller_id}</code> ] ÿßÿ≤ ŸæŸÜŸÑ ÿ≠ÿ∞ŸÅ ÿ¥ÿØ.",
        reply_markup=MANAGE_RESELLERS_KB,
        parse_mode="HTML"
    )
    del current_action[admin_id]

# ---------------- Report Generation (ÿßÿµŸÑÿßÿ≠‚Äåÿ¥ÿØŸá Ÿà async) ----------------
def now_shamsi_str() -> str:
    """
    ÿ®ÿ±⁄Øÿ±ÿØÿßŸÜÿØŸÜ ÿ™ÿßÿ±€åÿÆ Ÿà ÿ≥ÿßÿπÿ™ ŸÅÿπŸÑ€å ÿ®Ÿá ÿ¥ŸÖÿ≥€å
    ŸÅÿ±ŸÖÿ™: ÿ™ÿßÿ±€åÿÆ = [ 25 ŸÖŸáÿ± 1404 ] - ÿ≥ÿßÿπÿ™ = [ 23:17 ]
    """
    tz = ZoneInfo("Asia/Tehran")
    now = datetime.now(tz)
    
    shamsi = jdatetime.datetime.fromgregorian(datetime=now)
    
    month_names = {
        1: 'ŸÅÿ±Ÿàÿ±ÿØ€åŸÜ',
        2: 'ÿßÿ±ÿØ€åÿ®Ÿáÿ¥ÿ™',
        3: 'ÿÆÿ±ÿØÿßÿØ',
        4: 'ÿ™€åÿ±',
        5: 'ŸÖÿ±ÿØÿßÿØ',
        6: 'ÿ¥Ÿáÿ±€åŸàÿ±',
        7: 'ŸÖŸáÿ±',
        8: 'ÿ¢ÿ®ÿßŸÜ',
        9: 'ÿ¢ÿ∞ÿ±',
        10: 'ÿØ€å',
        11: 'ÿ®ŸáŸÖŸÜ',
        12: 'ÿßÿ≥ŸÅŸÜÿØ'
    }
    
    day = shamsi.day
    month = month_names[shamsi.month]
    year = shamsi.year
    time_str = shamsi.strftime("%H:%M:%S")
    
    return f"ÿ™ÿßÿ±€åÿÆ = [ {day} {month} {year} ] Ÿà ÿ≥ÿßÿπÿ™ = [ {time_str} ]"

def format_bytes(byte_count: int) -> str:
    """Convert bytes to human readable format with 2 decimal places, rounded up"""
    if byte_count is None: 
        return "N/A"
    
    power = 1024
    n = 0
    power_labels = {0: '', 1: 'K', 2: 'M', 3: 'G', 4: 'T'}
    
    while byte_count >= power and n < len(power_labels) - 1:
        byte_count /= power
        n += 1
    
    # ‚úÖ ⁄Øÿ±ÿØ ⁄©ÿ±ÿØŸÜ ÿ®Ÿá ÿ®ÿßŸÑÿß ÿ®ÿß ÿØŸà ÿ±ŸÇŸÖ ÿßÿπÿ¥ÿßÿ±
    rounded_value = math.ceil(byte_count * 100) / 100
    
    return f"{rounded_value:.2f} {power_labels[n]}B"
    
async def build_snapshot(tg_id: int) -> Dict:
    """
    Builds a comprehensive snapshot of user data per panel.
    Returns a dict with panel_id as key and panel data as value.
    """
    panels_snapshot = {}

    try:
        scoped_inbounds = await _get_scope_inbounds_by_panel(tg_id)

        if not scoped_inbounds:
            logging.warning(f"User {tg_id} has no valid panels or inbounds")
            return panels_snapshot

        now = time.time()

        # scoped_inbounds is a dict: {panel_id: [inbound_id1, inbound_id2, ...]}
        for panel_id, panel_inbound_ids in scoped_inbounds.items():
            # Get panel name from database
            async with aiosqlite.connect("data.db") as db:
                cur = await db.execute("SELECT panel_name FROM panels WHERE panel_id = ?", (panel_id,))
                row = await cur.fetchone()
                panel_name = row[0] if row else f"Panel {panel_id}"

            # Initialize snapshot for this panel
            snapshot = {
                "panel_name": panel_name,
                "counts": {"users": 0, "online": 0, "expiring": 0, "expired": 0},
                "lists": {"online": [], "expiring": [], "expired": []},
                "usage": {"used": 0, "capacity": 0, "remaining": 0, "unlimited": False},
                "timestamp": int(time.time())
            }

            processed_emails = set()
            total_inbound_used = 0
            total_inbound_capacity = 0
            has_unlimited = False

            try:
                api = await get_panel_api(panel_id)
                if not api:
                    logging.warning(f"Could not get API for panel {panel_id}, skipping...")
                    continue

                all_inbounds = api.inbounds()
                if not all_inbounds or not isinstance(all_inbounds, list):
                    logging.warning(f"Panel {panel_id}: No valid inbounds data")
                    continue

                online_clients_emails = set(api.online_clients())
                
                # Filter inbounds for this panel
                panel_inbound_set = set(panel_inbound_ids)
                filtered_inbounds = [
                    ib for ib in all_inbounds
                    if isinstance(ib, dict) and 'id' in ib and ib['id'] in panel_inbound_set
                ]
                
                for inbound in filtered_inbounds:
                    inbound_id = inbound.get('id')
                    if not inbound_id:
                        continue

                    # Extract clients from inbound
                    clients = _extract_clients_from_inbound(inbound)

                    if not clients:
                        logging.debug(f"Inbound {inbound_id}: No clients found")
                        continue
                        
                    # ‚úÖ Inbound-level usage
                    ib_up = int(inbound.get("up", 0) or 0)
                    ib_down = int(inbound.get("down", 0) or 0)
                    ib_total = int(inbound.get("total", 0) or 0)

                    total_inbound_used += (ib_up + ib_down)
                    if ib_total == 0:
                        has_unlimited = True
                    else:
                        total_inbound_capacity += ib_total

                    # Process each client
                    for client in clients:
                        try:
                            email = client.get('email', '').strip()
                            if not email or email in processed_emails:
                                continue

                            processed_emails.add(email)
                            snapshot["counts"]["users"] += 1

                            # Online status
                            enable = client.get('enable', True)
                            if enable and email in online_clients_emails:
                                snapshot["counts"]["online"] += 1
                                if email not in snapshot["lists"]["online"]:
                                    snapshot["lists"]["online"].append(email)

                            # Expiration status
                            is_expiring, is_expired = _calc_status_for_client(client, now)

                            if is_expired:
                                snapshot["counts"]["expired"] += 1
                                expired_entry = f"{email}"
                                if expired_entry not in snapshot["lists"]["expired"]:
                                    snapshot["lists"]["expired"].append(expired_entry)
                            elif is_expiring:
                                snapshot["counts"]["expiring"] += 1
                                expiring_entry = f"{email}"
                                if expiring_entry not in snapshot["lists"]["expiring"]:
                                    snapshot["lists"]["expiring"].append(expiring_entry)

                        except Exception as e:
                            logging.warning(f"Error processing client {client.get('email', 'unknown')}: {e}")
                            continue

            except Exception as e:
                log_error(e)
                logging.error(f"Error processing panel {panel_id} for user {tg_id}: {e}")
                continue

            # ‚úÖ Calculate final usage for this panel
            if has_unlimited:
                snapshot["usage"]["capacity"] = 0
                snapshot["usage"]["unlimited"] = True
                snapshot["usage"]["remaining"] = 0
                snapshot["usage"]["used"] = total_inbound_used
            else:
                snapshot["usage"]["used"] = total_inbound_used
                snapshot["usage"]["capacity"] = total_inbound_capacity
                snapshot["usage"]["remaining"] = max(total_inbound_capacity - total_inbound_used, 0)

            panels_snapshot[panel_id] = snapshot

    except Exception as e:
        log_error(e)
        logging.error(f"Error in build_snapshot for user {tg_id}: {e}")

    return panels_snapshot

# ============ Online/Expiring/Expired with Panel Selection ============

# --- Online Users ---
@dp.message(Command("online"))
async def online_cmd(m: Message):
    """ŸÜŸÖÿß€åÿ¥ ŸæŸÜŸÑ‚ÄåŸáÿß ÿ®ÿ±ÿß€å ŸÖÿ¥ÿßŸáÿØŸá ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ¢ŸÜŸÑÿß€åŸÜ"""
    await show_panel_selection_for_status(m, "online")

@dp.message(F.text == "üü¢ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ¢ŸÜŸÑÿß€åŸÜ")
async def btn_online(m: Message):
    await show_panel_selection_for_status(m, "online")


# --- Expiring Users ---
@dp.message(Command("expiring"))
async def expiring_cmd(m: Message):
    """ŸÜŸÖÿß€åÿ¥ ŸæŸÜŸÑ‚ÄåŸáÿß ÿ®ÿ±ÿß€å ŸÖÿ¥ÿßŸáÿØŸá ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ±Ÿà ÿ®Ÿá ÿßŸÜŸÇÿ∂ÿß"""
    await show_panel_selection_for_status(m, "expiring")

@dp.message(F.text == "‚è≥ ÿ±Ÿà ÿ®Ÿá ÿßŸÜŸÇÿ∂ÿß")
async def btn_expiring(m: Message):
    await show_panel_selection_for_status(m, "expiring")


# --- Expired Users ---
@dp.message(Command("expired"))
async def expired_cmd(m: Message):
    """ŸÜŸÖÿß€åÿ¥ ŸæŸÜŸÑ‚ÄåŸáÿß ÿ®ÿ±ÿß€å ŸÖÿ¥ÿßŸáÿØŸá ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ŸÖŸÜŸÇÿ∂€å‚Äåÿ¥ÿØŸá"""
    await show_panel_selection_for_status(m, "expired")

@dp.message(F.text == "üö´ ŸÖŸÜŸÇÿ∂€å‚Äåÿ¥ÿØŸá")
async def btn_expired(m: Message):
    await show_panel_selection_for_status(m, "expired")


# --- Helper Function: Show Panel Selection ---
async def show_panel_selection_for_status(m: Message, status_type: str):
    """
    ŸÜŸÖÿß€åÿ¥ ŸÑ€åÿ≥ÿ™ ŸæŸÜŸÑ‚ÄåŸáÿß ÿ®ÿ±ÿß€å ÿßŸÜÿ™ÿÆÿßÿ®
    status_type: 'online', 'expiring', 'expired'
    """
    panels_snap = await build_snapshot(m.from_user.id)
    
    if not panels_snap:
        await m.answer("‚ÑπÔ∏è Ÿá€å⁄Ü ÿØÿßÿØŸá‚Äåÿß€å ÿ®ÿ±ÿß€å ŸÜŸÖÿß€åÿ¥ Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ.")
        return

    # ÿß€åŸÖŸàÿ¨€å Ÿà ÿπŸÜŸàÿßŸÜ ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ŸÜŸàÿπ
    status_info = {
        "online": {"emoji": "üü¢", "title": "⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ¢ŸÜŸÑÿß€åŸÜ"},
        "expiring": {"emoji": "‚è≥", "title": "⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ±Ÿà ÿ®Ÿá ÿßŸÜŸÇÿ∂ÿß"},
        "expired": {"emoji": "üö´", "title": "⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ŸÖŸÜŸÇÿ∂€å‚Äåÿ¥ÿØŸá"}
    }
    
    emoji = status_info[status_type]["emoji"]
    title = status_info[status_type]["title"]

    # ÿ≥ÿßÿÆÿ™ ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å ÿßŸÜÿ™ÿÆÿßÿ® ŸæŸÜŸÑ
    buttons = []
    for panel_id, snapshot in panels_snap.items():
        panel_name = snapshot["panel_name"]
        count = snapshot["counts"].get(status_type, 0)
        
        if count > 0:  # ŸÅŸÇÿ∑ ŸæŸÜŸÑ‚ÄåŸáÿß€å€å ⁄©Ÿá ⁄©ÿßÿ±ÿ®ÿ± ÿØÿßÿ±ŸÜÿØ
            buttons.append([InlineKeyboardButton(
                text=f"üè¢ {safe_text(panel_name)} ({count})",
                callback_data=f"status_panel:{status_type}:{panel_id}"
            )])
    
    if not buttons:
        await m.answer(f"‚ÑπÔ∏è Ÿá€å⁄Ü ⁄©ÿßÿ±ÿ®ÿ± {title} €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.")
        return

    # ÿØ⁄©ŸÖŸá ÿ®ÿßÿ≤⁄Øÿ¥ÿ™
    buttons.append([InlineKeyboardButton(text="üè† ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å", callback_data="back_to_main")])

    kb = InlineKeyboardMarkup(inline_keyboard=buttons)
    await m.answer(
        f"{emoji} <b>ÿßŸÜÿ™ÿÆÿßÿ® ŸæŸÜŸÑ ÿ®ÿ±ÿß€å ŸÖÿ¥ÿßŸáÿØŸá {title}</b>\n\n"
        "ŸæŸÜŸÑ ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿÆŸàÿØ ÿ±ÿß ÿßÿ≤ ŸÑ€åÿ≥ÿ™ ÿ≤€åÿ± ÿßŸÜÿ™ÿÆÿßÿ® ŸÜŸÖÿß€å€åÿØ...",
        reply_markup=kb,
        parse_mode="HTML"
    )


# --- Callback: Show Users by Panel and Status ---
@dp.callback_query(F.data.startswith("status_panel:"))
async def show_users_by_panel_status(query: CallbackQuery):
    """
    ŸÜŸÖÿß€åÿ¥ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ €å⁄© ŸæŸÜŸÑ ÿÆÿßÿµ ÿ®ÿß Ÿàÿ∂ÿπ€åÿ™ ŸÖÿ¥ÿÆÿµ
    Format: status_panel:TYPE:PANEL_ID
    """
    try:
        parts = query.data.split(":")
        status_type = parts[1]  # online, expiring, expired
        panel_id = int(parts[2])
    except (IndexError, ValueError):
        await query.answer("‚ùå ÿÆÿ∑ÿß ÿØÿ± Ÿæÿ±ÿØÿßÿ≤ÿ¥ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™", show_alert=True)
        return

    # ÿß€åŸÖŸàÿ¨€å Ÿà ÿπŸÜŸàÿßŸÜ
    status_info = {
        "online": {"emoji": "üü¢", "title": "⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ¢ŸÜŸÑÿß€åŸÜ"},
        "expiring": {"emoji": "‚è≥", "title": "⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ±Ÿà ÿ®Ÿá ÿßŸÜŸÇÿ∂ÿß"},
        "expired": {"emoji": "üö´", "title": "⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ŸÖŸÜŸÇÿ∂€å‚Äåÿ¥ÿØŸá"}
    }
    
    emoji = status_info[status_type]["emoji"]
    title = status_info[status_type]["title"]

    # ÿØÿ±€åÿßŸÅÿ™ ÿßÿ∑ŸÑÿßÿπÿßÿ™
    panels_snap = await build_snapshot(query.from_user.id)
    
    if panel_id not in panels_snap:
        await query.message.edit_text("‚ÑπÔ∏è ÿßÿ∑ŸÑÿßÿπÿßÿ™ ŸæŸÜŸÑ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.")
        await query.answer()
        return

    snapshot = panels_snap[panel_id]
    panel_name = snapshot["panel_name"]
    user_list = snapshot["lists"].get(status_type, [])
    
    if not user_list:
        await query.message.edit_text(
            f"‚ÑπÔ∏è Ÿá€å⁄Ü ⁄©ÿßÿ±ÿ®ÿ± {title} ÿØÿ± ŸæŸÜŸÑ <b>{safe_text(panel_name)}</b> €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.",
            parse_mode="HTML"
        )
        await query.answer()
        return

    # ŸÅÿ±ŸÖÿ™ Ÿæ€åÿßŸÖ
    header = f"{emoji} <b>{title}</b>\n\n   üè¢ <b>ŸæŸÜŸÑ =</b> {safe_text(panel_name)}\n\n"
    msg = format_list(header, user_list)
    msg += f"\n\n<b>ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿØÿ± </b>{now_shamsi_str()}"

    # ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å ÿ¥€åÿ¥Ÿá‚Äåÿß€å
    buttons = []
    
    # ÿ±ÿØ€åŸÅ ÿßŸàŸÑ: ÿßŸÜÿ™ÿÆÿßÿ® ŸæŸÜŸÑ‚ÄåŸáÿß€å ÿØ€å⁄Øÿ± (ÿ¥€åÿ¥Ÿá‚Äåÿß€å)
    panel_buttons = []
    for pid, snap in panels_snap.items():
        count = snap["counts"].get(status_type, 0)
        if count > 0:
            panel_buttons.append(InlineKeyboardButton(
                text="üîò" if pid == panel_id else "‚ö™Ô∏è",
                callback_data=f"status_panel:{status_type}:{pid}"
            ))
    
    # ÿ™ŸÇÿ≥€åŸÖ ÿ®Ÿá ⁄ÜŸÜÿØ ÿ±ÿØ€åŸÅ ÿß⁄Øÿ± ÿ≤€åÿßÿØ ÿ®ŸàÿØŸÜÿØ (ÿ≠ÿØÿß⁄©ÿ´ÿ± 4 ÿØ⁄©ŸÖŸá ÿØÿ± Ÿáÿ± ÿ±ÿØ€åŸÅ)
    for i in range(0, len(panel_buttons), 4):
        buttons.append(panel_buttons[i:i+4])

    # ÿ±ÿØ€åŸÅ ÿØŸàŸÖ: ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å
    buttons.append([InlineKeyboardButton(
        text="‚ôªÔ∏è ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ®Ÿá ÿ¢ÿÆÿ±€åŸÜ Ÿàÿ∂ÿπ€åÿ™",
        callback_data=f"refresh_status:{status_type}:{panel_id}"
    )])

    # ÿ±ÿØ€åŸÅ ÿ≥ŸàŸÖ: ÿ®ÿßÿ≤⁄Øÿ¥ÿ™
    buttons.append([InlineKeyboardButton(
        text="‚¨ÖÔ∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÑ€åÿ≥ÿ™ ŸæŸÜŸÑ‚ÄåŸáÿß",
        callback_data=f"back_to_panel_list:{status_type}"
    )])

    kb = InlineKeyboardMarkup(inline_keyboard=buttons)
    
    await query.message.edit_text(msg, reply_markup=kb, parse_mode="HTML")
    await query.answer()


# --- Callback: Refresh Status ---
@dp.callback_query(F.data.startswith("refresh_status:"))
async def refresh_status(query: CallbackQuery):
    """
    ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸÑ€åÿ≥ÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ®ÿß Ÿàÿ∂ÿπ€åÿ™ ŸÖÿ¥ÿÆÿµ
    Format: refresh_status:TYPE:PANEL_ID
    """
    try:
        parts = query.data.split(":")
        status_type = parts[1]
        panel_id = int(parts[2])
    except (IndexError, ValueError):
        await query.answer("‚ùå ÿÆÿ∑ÿß ÿØÿ± Ÿæÿ±ÿØÿßÿ≤ÿ¥ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™", show_alert=True)
        return

    # ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÖÿ¨ÿØÿØ ÿßÿ≤ ÿ™ÿßÿ®ÿπ ŸÜŸÖÿß€åÿ¥
    await show_users_by_panel_status(query)
    await query.answer("‚úÖ ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ¥ÿØ", show_alert=False)


# --- Callback: Back to Panel List ---
@dp.callback_query(F.data.startswith("back_to_panel_list:"))
async def back_to_panel_list(query: CallbackQuery):
    """
    ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÑ€åÿ≥ÿ™ ŸæŸÜŸÑ‚ÄåŸáÿß
    Format: back_to_panel_list:TYPE
    """
    try:
        status_type = query.data.split(":")[1]
    except IndexError:
        await query.answer("‚ùå ÿÆÿ∑ÿß ÿØÿ± Ÿæÿ±ÿØÿßÿ≤ÿ¥ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™", show_alert=True)
        return

    # ÿ≥ÿßÿÆÿ™ ŸÖÿ¨ÿØÿØ ŸÑ€åÿ≥ÿ™ ŸæŸÜŸÑ‚ÄåŸáÿß
    panels_snap = await build_snapshot(query.from_user.id)
    
    if not panels_snap:
        await query.message.edit_text("‚ÑπÔ∏è Ÿá€å⁄Ü ÿØÿßÿØŸá‚Äåÿß€å ÿ®ÿ±ÿß€å ŸÜŸÖÿß€åÿ¥ Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ.")
        await query.answer()
        return

    status_info = {
        "online": {"emoji": "üü¢", "title": "⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ¢ŸÜŸÑÿß€åŸÜ"},
        "expiring": {"emoji": "‚è≥", "title": "⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ±Ÿà ÿ®Ÿá ÿßŸÜŸÇÿ∂ÿß"},
        "expired": {"emoji": "üö´", "title": "⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ŸÖŸÜŸÇÿ∂€å‚Äåÿ¥ÿØŸá"}
    }
    
    emoji = status_info[status_type]["emoji"]
    title = status_info[status_type]["title"]

    buttons = []
    for panel_id, snapshot in panels_snap.items():
        panel_name = snapshot["panel_name"]
        count = snapshot["counts"].get(status_type, 0)
        
        if count > 0:
            buttons.append([InlineKeyboardButton(
                text=f"üè¢ {safe_text(panel_name)} ({count})",
                callback_data=f"status_panel:{status_type}:{panel_id}"
            )])
    
    if not buttons:
        await query.message.edit_text(f"‚ÑπÔ∏è Ÿá€å⁄Ü ⁄©ÿßÿ±ÿ®ÿ± {title} €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.")
        await query.answer()
        return

    buttons.append([InlineKeyboardButton(text="üè† ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å", callback_data="back_to_main")])

    kb = InlineKeyboardMarkup(inline_keyboard=buttons)
    await query.message.edit_text(
        f"{emoji} <b>ÿßŸÜÿ™ÿÆÿßÿ® ŸæŸÜŸÑ ÿ®ÿ±ÿß€å ŸÖÿ¥ÿßŸáÿØŸá {title}</b>\n\n"
        "ŸæŸÜŸÑ ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿ±ÿß ÿßÿ≤ ŸÑ€åÿ≥ÿ™ ÿ≤€åÿ± ÿßŸÜÿ™ÿÆÿßÿ® ŸÜŸÖÿß€å€åÿØ...",
        reply_markup=kb,
        parse_mode="HTML"
    )
    await query.answer()


# --- Callback: Back to Main Menu ---
@dp.callback_query(F.data == "back_to_main")
async def back_to_main(query: CallbackQuery):
    """ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å"""
    await query.message.delete()
    await query.message.answer(
        "üè† ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å ÿ®ÿßÿ≤⁄Øÿ¥ÿ™€åÿØ.",
        reply_markup=get_main_kb(query.from_user.id)
    )
    await query.answer()

def format_panel_report(panel_name: str, counts: Dict[str, int], usage: Dict, is_superadmin: bool = False) -> str:
    """Format report for a single panel"""
    used_str = format_bytes(usage.get("used", 0))

    if usage.get("unlimited", False):
        remaining_str = "ŸÜÿßŸÖÿ≠ÿØŸàÿØ"
        capacity_line = ""
    else:
        remaining_str = format_bytes(usage.get("remaining", 0))
        capacity_line = f"üíæ <b>ÿ≠ÿ¨ŸÖ ÿ®ÿßŸÇ€å‚ÄåŸÖÿßŸÜÿØŸá:</b> [ {remaining_str} ]\n"

    if is_superadmin:
        header = f"üìä <b>⁄Øÿ≤ÿßÿ±ÿ¥ÿßÿ™ ŸÖÿ±ÿ®Ÿàÿ∑ ÿ®Ÿá ŸæŸÜŸÑ - [ {safe_text(panel_name)} ]</b>\n\n"
    else:
        header = f"üìä <b>⁄Øÿ≤ÿßÿ±ÿ¥ÿßÿ™ ŸÖÿ±ÿ®Ÿàÿ∑ ÿ®Ÿá ÿ≠ÿ≥ÿßÿ® ŸÜŸÖÿß€åŸÜÿØ⁄Ø€å</b>\nüè∑ <b>ŸÜÿßŸÖ ŸæŸÜŸÑ =</b> [ {safe_text(panel_name)} ]\n\n"

    return (
        header +
        f"üìà <b>ŸÖÿµÿ±ŸÅ ⁄©ŸÑ=</b> [ {used_str} ]\n" +
        capacity_line +
        f"üë• <b>⁄©ŸÑ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ =</b> [ {counts.get('users', 0)} ]\n"
        f"üü¢ <b>⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ¢ŸÜŸÑÿß€åŸÜ =</b> [ {counts.get('online', 0)} ]\n"
        f"‚è≥ <b>ÿ±Ÿà ÿ®Ÿá ÿßŸÜŸÇÿ∂ÿß =</b> [ {counts.get('expiring', 0)} ]\n"
        f"üö´ <b>ŸÖŸÜŸÇÿ∂€å ÿ¥ÿØŸá =</b> [ {counts.get('expired', 0)} ]"
    )

def format_main_report(counts: Dict[str,int], usage: Dict) -> str:
    used_str = format_bytes(usage.get("used", 0))

    if usage.get("unlimited", False):
        remaining_str = "ŸÜÿßŸÖÿ≠ÿØŸàÿØ"
    else:
        remaining_str = format_bytes(usage.get("remaining", 0))

    return (
        "üìä <b>⁄Øÿ≤ÿßÿ±ÿ¥ ŸÜŸáÿß€å€å ÿßÿ≤ Ÿàÿ∂ÿπ€åÿ™ ŸÅÿπŸÑ€å ÿ¥ŸÖÿß :</b>\n\n"
        f"üìà <b>ŸÖÿµÿ±ŸÅ ⁄©ŸÑ =</b> [ {used_str} ]\n"
        f"üíæ <b>ÿ≠ÿ¨ŸÖ ÿ®ÿßŸÇ€å‚ÄåŸÖÿßŸÜÿØŸá =</b> [ {remaining_str} ]\n\n"
        f"üë• <b>⁄©ŸÑ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ =</b> [ {counts.get('users',0)} ]\n"
        f"üü¢ <b>⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ¢ŸÜŸÑÿß€åŸÜ =</b> [ {counts.get('online',0)} ]\n"
        f"‚è≥ <b>ÿ±Ÿà ÿ®Ÿá ÿßŸÜŸÇÿ∂ÿß =</b> [ {counts.get('expiring',0)} ]\n"
        f"üö´ <b>ŸÖŸÜŸÇÿ∂€å ÿ¥ÿØŸá =</b> [ {counts.get('expired',0)} ]"
    )

def format_list(header_title: str, items: List[str]) -> str:
    msg = f"{header_title} [ {len(items)} ]\n\n"
    if items:
        msg += "\n".join([f"üë§ - [ <code>{safe_text(u)}</code> ]" for u in items])
    return msg

# ---------------- Commands ----------------
@dp.message(Command("start"))
async def start_cmd(m: Message):
    try:
        if REQUIRED_CHANNEL_ID:
            member = await bot.get_chat_member(REQUIRED_CHANNEL_ID, m.from_user.id)
            is_member = member.status in ("member", "administrator", "creator")
        else:
            is_member = True
    except Exception:
        is_member = False

    if not is_member:
        await m.answer(f"ÿ®ÿ±ÿß€å ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ ÿ±ÿ®ÿßÿ™ ÿßÿ®ÿ™ÿØÿß ÿ®ÿß€åÿØ ÿπÿ∂Ÿà ⁄©ÿßŸÜÿßŸÑ {REQUIRED_CHANNEL_ID} ÿ¥Ÿà€åÿØ.")
        return

    is_new = await ensure_user_and_check_new(m.from_user.id)
    kb = get_main_kb(m.from_user.id)
    await m.answer("üëã ÿ®Ÿá ÿ±ÿ®ÿßÿ™ ⁄Øÿ≤ÿßÿ±ÿ¥‚ÄåÿØŸá€å X-UI ÿÆŸàÿ¥ ÿ¢ŸÖÿØ€åÿØ!", reply_markup=kb)

    if is_new:
        u = m.from_user
        fullname = (u.first_name or "") + ((" " + u.last_name) if u.last_name else "")
        username = f"@{u.username}" if u.username else "N/A"
        uid = u.id
        date_str = now_shamsi_str()
        txt = (
            f"üë§ <b>€å⁄© ⁄©ÿßÿ±ÿ®ÿ± ÿ¨ÿØ€åÿØ</b> ÿ®ÿß ŸÖÿ¥ÿÆÿµÿßÿ™ ÿ≤€åÿ±ÿå ÿπÿ∂Ÿà ÿ±ÿ®ÿßÿ™ ÿ¥ÿØ...!\n\n"
            f"üìõ <b>ŸÜÿßŸÖ =</b> {safe_text(fullname)}\n"
            f"üÜî <b>€åŸàÿ≤ÿ±ŸÜ€åŸÖ =</b> {username}\n"
            f"üî¢ <b>ÿ¢€åÿØ€å =</b> [ <code>{uid}</code> ]\n"
            f"üìÖ <b>ÿπÿ∂Ÿà€åÿ™ ÿØÿ± =</b> {date_str}"
        )

        for admin_id in SUPERADMINS:
            try:
                await bot.send_message(admin_id, txt, parse_mode="HTML")
            except Exception as e:
                log_error(e)

@dp.message(Command("report"))
async def report_cmd(m: Message):
    panels_snap = await build_snapshot(m.from_user.id)
    
    if not panels_snap:
        await m.answer("‚ÑπÔ∏è Ÿá€å⁄Ü ÿØÿßÿØŸá‚Äåÿß€å ÿ®ÿ±ÿß€å ŸÜŸÖÿß€åÿ¥ Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ.\n\nüîç ŸÖŸÖ⁄©ŸÜ ÿßÿ≥ÿ™:\n‚Ä¢ ŸáŸÜŸàÿ≤ ÿß€åŸÜÿ®ŸÜÿØ€å ÿ®Ÿá ÿ¥ŸÖÿß ÿßÿÆÿ™ÿµÿßÿµ ÿØÿßÿØŸá ŸÜÿ¥ÿØŸá ÿ®ÿßÿ¥ÿØ\n‚Ä¢ €åÿß ÿß€åŸÜÿ®ÿßŸÜÿØŸáÿß€å ÿßÿÆÿ™ÿµÿßÿµ‚Äå€åÿßŸÅÿ™Ÿá ÿÆÿßŸÑ€å ÿ®ÿßÿ¥ŸÜÿØ")
        return

    is_superadmin = m.from_user.id in SUPERADMINS
    timestamp = now_shamsi_str()
    
    # Send separate report for each panel
    for panel_id, snapshot in panels_snap.items():
        if snapshot["counts"]["users"] == 0:
            continue
            
        msg = format_panel_report(
            snapshot["panel_name"],
            snapshot["counts"],
            snapshot["usage"],
            is_superadmin
        ) + f"\n\n<b>ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿØÿ±</b> {timestamp}"
        
        kb = InlineKeyboardMarkup(
            inline_keyboard=[[InlineKeyboardButton(
                text="‚ôªÔ∏è ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ®Ÿá ÿ¢ÿÆÿ±€åŸÜ Ÿàÿ∂ÿπ€åÿ™",
                callback_data=f"refresh_report:{panel_id}"
            )]]
        )
        await m.answer(msg, reply_markup=kb, parse_mode="HTML")
        await asyncio.sleep(0.3)  # Avoid rate limit

@dp.callback_query(F.data.startswith("refresh_report:"))
async def refresh_report(query: CallbackQuery):
    try:
        panel_id = int(query.data.split(":")[1])
    except (IndexError, ValueError):
        await query.answer("‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿ¥ŸÜÿßÿ≥ÿß€å€å ŸæŸÜŸÑ", show_alert=True)
        return
    
    panels_snap = await build_snapshot(query.from_user.id)
    
    if panel_id not in panels_snap:
        await query.message.edit_text("‚ÑπÔ∏è Ÿá€å⁄Ü ÿØÿßÿØŸá‚Äåÿß€å ÿ®ÿ±ÿß€å ŸÜŸÖÿß€åÿ¥ Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ.")
        await query.answer()
        return
    
    snapshot = panels_snap[panel_id]
    
    if snapshot["counts"]["users"] == 0:
        await query.message.edit_text("‚ÑπÔ∏è Ÿá€å⁄Ü ÿØÿßÿØŸá‚Äåÿß€å ÿ®ÿ±ÿß€å ŸÜŸÖÿß€åÿ¥ Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ.")
        await query.answer()
        return

    is_superadmin = query.from_user.id in SUPERADMINS
    new_msg = format_panel_report(
        snapshot["panel_name"],
        snapshot["counts"],
        snapshot["usage"],
        is_superadmin
    ) + f"\n\nÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿØÿ± {now_shamsi_str()}"
    
    kb = InlineKeyboardMarkup(
        inline_keyboard=[[InlineKeyboardButton(
            text="‚ôªÔ∏è ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ®Ÿá ÿ¢ÿÆÿ±€åŸÜ Ÿàÿ∂ÿπ€åÿ™",
            callback_data=f"refresh_report:{panel_id}"
        )]]
    )
    
    if query.message.text != new_msg:
        await query.message.edit_text(new_msg, reply_markup=kb, parse_mode="HTML")
        await query.answer("‚úÖ ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ¥ÿØ", show_alert=False)
    else:
        await query.answer("‚ÑπÔ∏è ÿ®ÿØŸàŸÜ ÿ™ÿ∫€å€åÿ±", show_alert=False)

@dp.message(F.text == "üìä ⁄Øÿ≤ÿßÿ±ÿ¥ ⁄©ŸÑ€å")
async def btn_report(m: Message):
    await report_cmd(m)

@dp.message(F.text == "üü¢ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ¢ŸÜŸÑÿß€åŸÜ")
async def btn_online(m: Message):
    await online_cmd(m)

@dp.message(F.text == "‚è≥ ÿ±Ÿà ÿ®Ÿá ÿßŸÜŸÇÿ∂ÿß")
async def btn_expiring(m: Message):
    await expiring_cmd(m)

@dp.message(F.text == "üö´ ŸÖŸÜŸÇÿ∂€å‚Äåÿ¥ÿØŸá")
async def btn_expired(m: Message):
    await expired_cmd(m)

# ---------------- Full Reports & Change Notifications ----------------

def _format_expiring_msg_super_with_panel(name: str, panel_name: str) -> str:
    return (
        "üì¢ <b>ŸÖÿØ€åÿ± ŸÖÿ≠ÿ™ÿ±ŸÖ ... </b>\n\n"
        "‚è≥ ÿßÿ¥ÿ™ÿ±ÿß⁄© ÿ®ÿß ŸÖÿ¥ÿÆÿµÿßÿ™ ÿ≤€åÿ±ÿå <b>[ ÿ®ÿ≤ŸàÿØ€å ]</b> ŸÖŸÜŸÇÿ∂€å ÿÆŸàÿßŸáÿØ ÿ¥ÿØ ... \n\n"
        f"üè¢ <b>ŸæŸÜŸÑ =</b> [ {safe_text(panel_name)} ]\n"
        f"üë• <b>⁄©ÿßÿ±ÿ®ÿ± =</b> [ <code>{safe_text(name)}</code> ]\n\n"
        "+ <b>ÿØÿ±ÿµŸàÿ±ÿ™ ÿ™ŸÖÿß€åŸÑ ÿå ŸÜÿ≥ÿ®ÿ™ ÿ®Ÿá ÿ¥ÿßÿ±⁄ò ŸÖÿ¨ÿØÿØ ÿßÿ≤ ÿØÿßÿÆŸÑ ŸæŸÜŸÑ ⁄©ÿßÿ±ÿ®ÿ±€å ÿÆŸàÿØ ÿßŸÇÿØÿßŸÖ ⁄©ŸÜ€åÿØ </b>"
    )

def _format_expired_msg_super_with_panel(name: str, panel_name: str) -> str:
    return (
        "üì¢ <b>ŸÖÿØ€åÿ± ŸÖÿ≠ÿ™ÿ±ŸÖ ... </b>\n\n"
        "üö´ ÿßÿ¥ÿ™ÿ±ÿß⁄© ÿ®ÿß ŸÖÿ¥ÿÆÿµÿßÿ™ ÿ≤€åÿ± ÿå <b>[ ŸÖŸÜŸÇÿ∂€å ]</b> ⁄Øÿ±ÿØ€åÿØŸá ÿßÿ≥ÿ™ ... \n\n"
        f"üè¢ <b>ŸæŸÜŸÑ =</b> [ {safe_text(panel_name)} ]\n"
        f"üë• <b>⁄©ÿßÿ±ÿ®ÿ± =</b> [ <code>{safe_text(name)}</code> ]\n\n"
        "+ <b>ÿØÿ±ÿµŸàÿ±ÿ™ ÿ™ŸÖÿß€åŸÑ ÿå ŸÜÿ≥ÿ®ÿ™ ÿ®Ÿá ÿ¥ÿßÿ±⁄ò ŸÖÿ¨ÿØÿØ ÿßÿ≤ ÿØÿßÿÆŸÑ ŸæŸÜŸÑ ⁄©ÿßÿ±ÿ®ÿ±€å ÿÆŸàÿØ ÿßŸÇÿØÿßŸÖ ⁄©ŸÜ€åÿØ </b>"
    )

def _format_expiring_msg_reseller_with_panel(name: str, panel_name: str) -> str:
    return (
        "üì¢ <b>ŸÜŸÖÿß€åŸÜÿØŸá ŸÖÿ≠ÿ™ÿ±ŸÖ ... </b>\n\n"
        "‚è≥ ÿßÿ¥ÿ™ÿ±ÿß⁄© ÿ®ÿß ŸÖÿ¥ÿÆÿµÿßÿ™ ÿ≤€åÿ±ÿå <b>[ ÿ®ÿ≤ŸàÿØ€å ]</b> ŸÖŸÜŸÇÿ∂€å ÿÆŸàÿßŸáÿØ ÿ¥ÿØ ... \n\n"
        f"üè¢ <b>ŸæŸÜŸÑ =</b> [ {safe_text(panel_name)} ]\n"
        f"üë• <b>⁄©ÿßÿ±ÿ®ÿ± =</b> [ <code>{safe_text(name)}</code> ]\n\n"
        "+ <b>ÿØÿ±ÿµŸàÿ±ÿ™ ÿ™ŸÖÿß€åŸÑ ÿå ŸÜÿ≥ÿ®ÿ™ ÿ®Ÿá ÿ¥ÿßÿ±⁄ò ŸÖÿ¨ÿØÿØ ⁄©ÿßÿ±ÿ®ÿ± ÿÆŸàÿØ ÿßŸÇÿØÿßŸÖ ⁄©ŸÜ€åÿØ </b>"
    )

def _format_expired_msg_reseller_with_panel(name: str, panel_name: str) -> str:
    return (
        "üì¢ <b>ŸÜŸÖÿß€åŸÜÿØŸá ŸÖÿ≠ÿ™ÿ±ŸÖ ... </b>\n\n"
        "üö´ ÿßÿ¥ÿ™ÿ±ÿß⁄© ÿ®ÿß ŸÖÿ¥ÿÆÿµÿßÿ™ ÿ≤€åÿ± ÿå <b>[ ŸÖŸÜŸÇÿ∂€å ]</b> ⁄Øÿ±ÿØ€åÿØŸá ÿßÿ≥ÿ™ ... \n\n"
        f"üè¢ <b>ŸæŸÜŸÑ =</b> [ {safe_text(panel_name)} ]\n"
        f"üë• <b>⁄©ÿßÿ±ÿ®ÿ± =</b> [ <code>{safe_text(name)}</code> ]\n\n"
        "+ <b>ÿØÿ±ÿµŸàÿ±ÿ™ ÿ™ŸÖÿß€åŸÑ ÿå ŸÜÿ≥ÿ®ÿ™ ÿ®Ÿá ÿ¥ÿßÿ±⁄ò ŸÖÿ¨ÿØÿØ ⁄©ÿßÿ±ÿ®ÿ± ÿÆŸàÿØ ÿßŸÇÿØÿßŸÖ ⁄©ŸÜ€åÿØ </b>"
    )

async def send_full_reports():
    """Sends daily full reports to resellers and superadmins - one message per panel."""
    try:
        users_to_report = set(SUPERADMINS)

        async with aiosqlite.connect("data.db") as db:
            cur = await db.execute("SELECT DISTINCT telegram_id FROM reseller_inbounds")
            rows = await cur.fetchall()
            for (tg_id,) in rows:
                users_to_report.add(tg_id)

        for tg_id in users_to_report:
            try:
                panels_snap = await build_snapshot(tg_id)

                if not panels_snap:
                    logging.info(f"Skipping report for {tg_id}: No panels found")
                    continue

                is_superadmin = tg_id in SUPERADMINS
                timestamp = now_shamsi_str()

                # Send one message per panel
                for panel_id, snapshot in panels_snap.items():
                    if snapshot["counts"]["users"] == 0:
                        continue

                    report = format_panel_report(
                        snapshot["panel_name"],
                        snapshot["counts"],
                        snapshot["usage"],
                        is_superadmin
                    ) + f"\n\nÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿØÿ± {timestamp}"
                    
                    kb = InlineKeyboardMarkup(
                        inline_keyboard=[[InlineKeyboardButton(
                            text="‚ôªÔ∏è ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ®Ÿá ÿ¢ÿÆÿ±€åŸÜ Ÿàÿ∂ÿπ€åÿ™",
                            callback_data=f"refresh_report:{panel_id}"
                        )]]
                    )

                    await bot.send_message(tg_id, report, reply_markup=kb, parse_mode="HTML")
                    await asyncio.sleep(0.5)  # Rate limit

                # Update last report in DB (store all panels data)
                async with aiosqlite.connect("data.db") as db:
                    await db.execute(
                        "INSERT OR REPLACE INTO last_reports(telegram_id, last_json, last_full_report) VALUES (?, ?, ?)",
                        (tg_id, json.dumps(panels_snap), int(time.time()))
                    )
                    await db.commit()

            except TelegramForbiddenError:
                logging.warning(f"‚ùå User {tg_id} has blocked the bot")
            except Exception as e:
                log_error(e)
                logging.error(f"Failed to send report to {tg_id}: {e}")

    except Exception as e:
        log_error(e)
        logging.error(f"Error in send_full_reports: {e}")

    logging.info("‚úÖ Daily Reports Completed.")

async def check_for_changes():
    """
    Periodically checks for changes in user statuses (expiring/expired).
    Sends notifications if new users are detected in those categories.
    """
    logging.info("üîç Checking for Changes in user Statuses...")

    try:
        users_to_check = set(SUPERADMINS)

        async with aiosqlite.connect("data.db") as db:
            cur = await db.execute("SELECT DISTINCT telegram_id FROM reseller_inbounds")
            rows = await cur.fetchall()
            for (tg_id,) in rows:
                users_to_check.add(tg_id)

        for tg_id in users_to_check:
            try:
                is_super = tg_id in SUPERADMINS

                # ‚úÖ Build current snapshot (per panel)
                current_panels_snap = await build_snapshot(tg_id)
                
                # ‚úÖ Check if snapshot is empty
                if not current_panels_snap:
                    logging.info(f"User {tg_id}: No panels or data, skipping change detection")
                    continue

                # Load previous snapshot
                async with aiosqlite.connect("data.db") as db:
                    cur = await db.execute(
                        "SELECT last_json FROM last_reports WHERE telegram_id=?",
                        (tg_id,)
                    )
                    row = await cur.fetchone()

                if not row or not row[0]:
                    # First time - store current snapshot
                    async with aiosqlite.connect("data.db") as db:
                        await db.execute(
                            "INSERT OR REPLACE INTO last_reports(telegram_id, last_json, last_full_report) VALUES (?, ?, ?)",
                            (tg_id, json.dumps(current_panels_snap), int(time.time()))
                        )
                        await db.commit()
                    logging.info(f"User {tg_id} = First SnapShot stored")
                    continue

                try:
                    prev_panels_snap = json.loads(row[0])
                except (json.JSONDecodeError, TypeError):
                    prev_panels_snap = {}

                # ‚úÖ Compare per panel
                for panel_id, current_snap in current_panels_snap.items():
                    panel_id_str = str(panel_id)
                    
                    # Check if we have counts in current snapshot
                    if "counts" not in current_snap or "lists" not in current_snap:
                        logging.warning(f"User {tg_id}, Panel {panel_id}: Invalid snapshot structure")
                        continue
                    
                    prev_snap = prev_panels_snap.get(panel_id_str, {})
                    
                    # If no previous data for this panel, skip notifications
                    if not prev_snap or "lists" not in prev_snap:
                        continue

                    current_expiring = set(current_snap["lists"].get("expiring", []))
                    current_expired = set(current_snap["lists"].get("expired", []))
                    
                    prev_expiring = set(prev_snap["lists"].get("expiring", []))
                    prev_expired = set(prev_snap["lists"].get("expired", []))

                    # Find newly expiring and expired users
                    newly_expiring = current_expiring - prev_expiring
                    newly_expired = current_expired - prev_expired

                    panel_name = current_snap.get("panel_name", f"Panel {panel_id}")

                    # Send notifications for newly expiring users
                    if newly_expiring:
                        for name in newly_expiring:
                            if is_super:
                                msg = _format_expiring_msg_super_with_panel(name, panel_name)
                            else:
                                msg = _format_expiring_msg_reseller_with_panel(name, panel_name)
                            try:
                                await bot.send_message(tg_id, msg, parse_mode="HTML")
                                await asyncio.sleep(0.3)
                            except TelegramForbiddenError:
                                logging.warning(f"‚ö†Ô∏è ⁄©ÿßÿ±ÿ®ÿ± {tg_id} ÿ±ÿ®ÿßÿ™ ÿ±ÿß ÿ®ŸÑÿß⁄© ⁄©ÿ±ÿØŸá ÿßÿ≥ÿ™.")
                                break
                            except Exception as e:
                                log_error(e)

                    # Send notifications for newly expired users
                    if newly_expired:
                        for name in newly_expired:
                            if is_super:
                                msg = _format_expired_msg_super_with_panel(name, panel_name)
                            else:
                                msg = _format_expired_msg_reseller_with_panel(name, panel_name)
                            try:
                                await bot.send_message(tg_id, msg, parse_mode="HTML")
                                await asyncio.sleep(0.3)
                            except TelegramForbiddenError:
                                logging.warning(f"‚ö†Ô∏è ⁄©ÿßÿ±ÿ®ÿ± {tg_id} ÿ±ÿ®ÿßÿ™ ÿ±ÿß ÿ®ŸÑÿß⁄© ⁄©ÿ±ÿØŸá ÿßÿ≥ÿ™.")
                                break
                            except Exception as e:
                                log_error(e)

                # Update the database with current snapshot (all panels)
                async with aiosqlite.connect("data.db") as db:
                    await db.execute(
                        "INSERT OR REPLACE INTO last_reports(telegram_id, last_json, last_full_report) VALUES (?, ?, ?)",
                        (tg_id, json.dumps(current_panels_snap), int(time.time()))
                    )
                    await db.commit()

                await asyncio.sleep(0.5)

            except Exception as e:
                log_error(e)
                logging.error(f"  ‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿ®ÿ±ÿ±ÿ≥€å {tg_id}: {e}")
                continue

    except Exception as e:
        log_error(e)
        logging.error(f"Error in check_for_changes: {e}")

    logging.info("‚úÖ The entire Panel was Successfully reviewed.")

# ---------------- Cancel Action ----------------
@dp.callback_query(F.data == "cancel_action")
async def cancel_action(c: CallbackQuery):
    if c.from_user.id in current_action:
        del current_action[c.from_user.id]
    await c.message.edit_text("‚ùå ÿπŸÖŸÑ€åÿßÿ™ ŸÑÿ∫Ÿà ÿ¥ÿØ.", reply_markup=get_main_kb(c.from_user.id))
    await c.answer()

@dp.callback_query(F.data == "back_to_main_menu_superadmin")
async def back_to_main_menu_superadmin(c: CallbackQuery):
    if c.from_user.id not in SUPERADMINS: return
    if c.from_user.id in current_action:
        del current_action[c.from_user.id]
    await c.message.edit_text("üè† ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å ÿ®ÿßÿ≤⁄Øÿ¥ÿ™€åÿØ.", reply_markup=get_main_kb(c.from_user.id))
    await c.answer()

# ---------------- Main ----------------
async def main():
    await ensure_db()

    # üïí Daily report scheduled dynamically by .env
    scheduler.add_job(
        send_full_reports,
        'cron',
        hour=DAILY_REPORT_HOUR,
        minute=DAILY_REPORT_MINUTE,
        timezone=ZoneInfo("Asia/Tehran"),
        id='daily_report',
        replace_existing=True
    )

    # üîÅ Change detection dynamically by .env
    scheduler.add_job(
        check_for_changes,
        'interval',
        minutes=CHANGE_CHECK_INTERVAL_MINUTES,
        timezone=ZoneInfo("Asia/Tehran"),
        id='change_detection',
        replace_existing=True
    )

    scheduler.start()

    # üìã Log the dynamic cron configuration
    logging.info("‚úÖ Schedulers initialized from .env configuration:")
    logging.info(f"‚è∞ DAILY_REPORT_HOUR = {DAILY_REPORT_HOUR}")
    logging.info(f"‚è∞ DAILY_REPORT_MINUTE = {DAILY_REPORT_MINUTE}")
    logging.info(f"üîÅ CHANGE_CHECK_INTERVAL_MINUTES = {CHANGE_CHECK_INTERVAL_MINUTES}")

    logging.info("Bot has Started Successfully")
    
    await dp.start_polling(bot)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logging.info("Bot has Stopped by User")
    except Exception as e:
        log_error(e)
        logging.error(f"Fatal error: {e}")
